{"ast":null,"code":"import _defineProperty from\"C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";import _createForOfIteratorHelper from\"C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _objectSpread from\"C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// GameLogic.js\nimport React,{Component}from'react';import{GridGenerator,HexGrid,Layout,Path,Text,Hexagon,HexUtils}from'react-hexgrid';import'./App.css';import ConfirmationModal from'./ConfirmationModal';// Import the ConfirmationModal component\n// Calculate the player's score (number of hexagons they own)\nfunction calculatePlayerScore(currentPlayer,hexagons){return hexagons.reduce(function(count,hex){return hex.owner===currentPlayer.id?count+1:count;},0);}// Update the player's score\nfunction updatePlayerScore(players,currentPlayer,playerScore){return players.map(function(player){if(player.id===currentPlayer.id){return _objectSpread(_objectSpread({},player),{},{score:player.score+playerScore});}return player;});}// Check for victory condition (score >= 100)\nfunction checkVictoryCondition(currentPlayer,playerScore){return currentPlayer.score+playerScore>=100;}// Find the next valid player that is not player 0\nfunction findNextPlayerIndex(currentPlayerIndex,players){var nextPlayerIndex=(currentPlayerIndex+1)%players.length;while(players[nextPlayerIndex].id===0){nextPlayerIndex=(nextPlayerIndex+1)%players.length;}return nextPlayerIndex;}// Resets the \"moved\" status of all units\nfunction resetMovedUnits(hexagons){var updatedHexagons=hexagons.map(function(hex){return _objectSpread(_objectSpread({},hex),{},{moved:false,attack:false,count:null});});return updatedHexagons;}// Function to check if a hexagon is adjacent to to an enemy unit or surrounded by hexagons with a different owner\nfunction checkSurroundedHexagons(hexagons){var updatedHexagons=hexagons.map(function(hex){var adjacentHexagons=hexagons.filter(function(adjHex){if(HexUtils.distance(hex,adjHex)===1){return adjHex;}return null;});var adjacentHexagons2=hexagons.filter(function(adjHex2){//this is not being used anymore?\nif(HexUtils.distance(hex,adjHex2)===2){return adjHex2;}return null;});var adjacentByDifferentPlayer=adjacentHexagons.length>0&&adjacentHexagons.some(function(adjHex){return adjHex.hasUnit&&hex.hasUnit&&adjHex.owner!==hex.owner;});if(!adjacentByDifferentPlayer){hex.adjacent=false;}var pushBlock=adjacentHexagons.filter(function(adjHex){return adjHex.hasUnit&&hex.hasUnit&&hex.owner!=adjHex.owner;});var _iterator=_createForOfIteratorHelper(pushBlock),_step;try{var _loop=function _loop(){var pushHex=_step.value;// Calculate the direction separately for each axis\nvar direction={q:pushHex.q-hex.q,r:pushHex.r-hex.r,s:pushHex.s-hex.s};// Calculate the position of the unit behind the adjacent hexagon\nvar behindHex={q:pushHex.q+direction.q,r:pushHex.r+direction.r,s:pushHex.s+direction.s};// Find the hexagon at the behindHex position\nvar behindHexagon=hexagons.find(function(hex){return HexUtils.equals(hex,behindHex);});if(behindHexagon==undefined){//if behindHex is outside the gameboard, we can push it\nhex.adjacent=true;return{v:void 0};}else if(pushHex.hasUnit&&!behindHexagon.hasUnit){hex.adjacent=true;return{v:void 0};}else hex.adjacent=false;},_ret;for(_iterator.s();!(_step=_iterator.n()).done;){_ret=_loop();if(_ret)return _ret.v;}//PUSHBLOCK\n}catch(err){_iterator.e(err);}finally{_iterator.f();}var surroundedByDifferentPlayer=adjacentHexagons.length>5&&adjacentHexagons.every(function(adjHex){return adjHex.owner!==0&&adjHex.owner!==hex.owner&&adjHex.owner===adjacentHexagons[0].owner;});if(surroundedByDifferentPlayer){// Find the most common owner among surrounding hexagons\nvar owners=adjacentHexagons.filter(function(adjHex){return adjHex.owner!==0;}).map(function(adjHex){return adjHex.owner;});var mostCommonOwner=owners.reduce(function(acc,owner){return _objectSpread(_objectSpread({},acc),{},_defineProperty({},owner,(acc[owner]||0)+1));},{});var newOwner=parseInt(Object.keys(mostCommonOwner).find(function(owner){return mostCommonOwner[owner]===6;})||0);// Update the owner to the most common owner\nhex.owner=newOwner;if(hex.hasUnit){alert('You made a new friend!');// Do any necessary actions when a unit is present\n}else{// Handle when there's no unit\nalert('You made a new friend!');hex.hasUnit=true;}}return hex;});return updatedHexagons;}export{calculatePlayerScore,updatePlayerScore,checkVictoryCondition,findNextPlayerIndex,resetMovedUnits,checkSurroundedHexagons};","map":{"version":3,"names":["React","Component","GridGenerator","HexGrid","Layout","Path","Text","Hexagon","HexUtils","ConfirmationModal","calculatePlayerScore","currentPlayer","hexagons","reduce","count","hex","owner","id","updatePlayerScore","players","playerScore","map","player","_objectSpread","score","checkVictoryCondition","findNextPlayerIndex","currentPlayerIndex","nextPlayerIndex","length","resetMovedUnits","updatedHexagons","moved","attack","checkSurroundedHexagons","adjacentHexagons","filter","adjHex","distance","adjacentHexagons2","adjHex2","adjacentByDifferentPlayer","some","hasUnit","adjacent","pushBlock","_iterator","_createForOfIteratorHelper","_step","_loop","pushHex","value","direction","q","r","s","behindHex","behindHexagon","find","equals","undefined","v","_ret","n","done","err","e","f","surroundedByDifferentPlayer","every","owners","mostCommonOwner","acc","_defineProperty","newOwner","parseInt","Object","keys","alert"],"sources":["C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/src/GameLogic.js"],"sourcesContent":["// GameLogic.js\r\n\r\nimport React, { Component } from 'react';\r\nimport { GridGenerator, HexGrid, Layout, Path, Text, Hexagon, HexUtils } from 'react-hexgrid';\r\nimport './App.css';\r\nimport ConfirmationModal from './ConfirmationModal'; // Import the ConfirmationModal component\r\n\r\n\r\n// Calculate the player's score (number of hexagons they own)\r\nfunction calculatePlayerScore(currentPlayer, hexagons) {\r\n  return hexagons.reduce((count, hex) => {\r\n    return hex.owner === currentPlayer.id ? count + 1 : count;\r\n  }, 0);\r\n}\r\n\r\n// Update the player's score\r\nfunction updatePlayerScore(players, currentPlayer, playerScore) {\r\n  return players.map(player => {\r\n    if (player.id === currentPlayer.id) {\r\n      return { ...player, score: player.score + playerScore };\r\n    }\r\n    return player;\r\n  });\r\n}\r\n\r\n// Check for victory condition (score >= 100)\r\nfunction checkVictoryCondition(currentPlayer, playerScore) {\r\n  return currentPlayer.score + playerScore >= 100;\r\n}\r\n\r\n// Find the next valid player that is not player 0\r\nfunction findNextPlayerIndex(currentPlayerIndex, players) {\r\n  let nextPlayerIndex = (currentPlayerIndex + 1) % players.length;\r\n  while (players[nextPlayerIndex].id === 0) {\r\n    nextPlayerIndex = (nextPlayerIndex + 1) % players.length;\r\n  }\r\n  return nextPlayerIndex;\r\n}\r\n\r\n// Resets the \"moved\" status of all units\r\nfunction resetMovedUnits(hexagons) {\r\n  const updatedHexagons = hexagons.map(hex => {\r\n    return { ...hex, moved: false, attack: false, count: null};\r\n  });\r\n  return updatedHexagons;\r\n}\r\n\r\n\r\n// Function to check if a hexagon is adjacent to to an enemy unit or surrounded by hexagons with a different owner\r\nfunction checkSurroundedHexagons(hexagons) {\r\n  const updatedHexagons = hexagons.map(hex => {\r\n    const adjacentHexagons = hexagons.filter(adjHex => {\r\n      if (HexUtils.distance(hex, adjHex) === 1) {\r\n        return adjHex;\r\n      }\r\n      return null;\r\n    });\r\n\t\r\n\t\r\n   const adjacentHexagons2 = hexagons.filter(adjHex2 => { //this is not being used anymore?\r\n      if (HexUtils.distance(hex, adjHex2) === 2) {\r\n        return adjHex2;\r\n      }\r\n      return null;\r\n });\t  \r\n\t\t\r\n\tconst adjacentByDifferentPlayer = \r\n\tadjacentHexagons.length > 0 &&\r\n      adjacentHexagons.some(\r\n        adjHex => adjHex.hasUnit && hex.hasUnit && adjHex.owner !== hex.owner\r\n      );\t  \r\n\t  \r\n\tif (!adjacentByDifferentPlayer) {\r\n\t\thex.adjacent = false;\r\n\t}\t\r\n\r\n  const pushBlock = adjacentHexagons.filter(adjHex => adjHex.hasUnit && hex.hasUnit && hex.owner != adjHex.owner);\r\n \r\n  for (const pushHex of pushBlock) {\r\n    // Calculate the direction separately for each axis\r\n    const direction = {\r\n      q: pushHex.q - hex.q,\r\n      r: pushHex.r - hex.r,\r\n      s: pushHex.s - hex.s,\r\n    };\r\n\r\n    // Calculate the position of the unit behind the adjacent hexagon\r\n    const behindHex = {\r\n      q: pushHex.q + direction.q,\r\n      r: pushHex.r + direction.r,\r\n      s: pushHex.s + direction.s,\r\n    };\r\n\r\n    // Find the hexagon at the behindHex position\r\n    const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\r\n\r\n\tif (behindHexagon == undefined) {\t//if behindHex is outside the gameboard, we can push it\r\n\t\thex.adjacent = true;\r\n\t\treturn;\r\n\t } else if(pushHex.hasUnit && !behindHexagon.hasUnit) { \r\n\t\t hex.adjacent = true;\r\n\t\t return;\r\n\t }\telse\r\n\t\t hex.adjacent = false;\t \r\n  }  \r\n\t//PUSHBLOCK\r\n\r\n    const surroundedByDifferentPlayer =\r\n      adjacentHexagons.length > 5 &&\r\n      adjacentHexagons.every(\r\n        adjHex => adjHex.owner !== 0 && adjHex.owner !== hex.owner && adjHex.owner === adjacentHexagons[0].owner\r\n      );\r\n\t  \r\n    if (surroundedByDifferentPlayer) {\r\n      // Find the most common owner among surrounding hexagons\r\n      const owners = adjacentHexagons\r\n        .filter(adjHex => adjHex.owner !== 0)\r\n        .map(adjHex => adjHex.owner);\r\n\r\n      const mostCommonOwner = owners\r\n        .reduce(\r\n          (acc, owner) => ({\r\n            ...acc,\r\n            [owner]: (acc[owner] || 0) + 1\r\n          }),\r\n          {}\r\n        );\r\n\r\n      const newOwner = parseInt(\r\n        Object.keys(mostCommonOwner).find(owner => mostCommonOwner[owner] === 6) || 0\r\n      );\r\n\r\n      // Update the owner to the most common owner\r\n      hex.owner = newOwner;\r\n\r\n      if (hex.hasUnit) {\r\n        alert('You made a new friend!');\r\n        // Do any necessary actions when a unit is present\r\n      } else {\r\n        // Handle when there's no unit\r\n        alert('You made a new friend!');\r\n        hex.hasUnit = true;\r\n      }\r\n    }\r\n\t\r\n    return hex;\r\n  });\r\n\r\n  return updatedHexagons;\r\n}\r\n\r\nexport{\r\n  calculatePlayerScore,\r\n  updatePlayerScore,\r\n  checkVictoryCondition,\r\n  findNextPlayerIndex,\r\n  resetMovedUnits,\r\n  checkSurroundedHexagons\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}