{"ast":null,"code":"import _toConsumableArray from\"C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _objectSpread from\"C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _classCallCheck from\"C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/node_modules/@babel/runtime/helpers/esm/createClass.js\";import _inherits from\"C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/node_modules/@babel/runtime/helpers/esm/inherits.js\";import _createSuper from\"C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/node_modules/@babel/runtime/helpers/esm/createSuper.js\";/* src/HexagonalGrid.js */import React,{Component}from'react';import{GridGenerator,HexGrid,Layout,Path,Text,Hexagon,HexUtils}from'react-hexgrid';import'./App.css';import ConfirmationModal from'./ConfirmationModal';// Import the ConfirmationModal component\nimport{calculatePlayerScore,updatePlayerScore,checkVictoryCondition,findNextPlayerIndex,resetMovedUnits,checkSurroundedHexagons}from'./GameLogic';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";import{Fragment as _Fragment}from\"react/jsx-runtime\";var App=/*#__PURE__*/function(_Component){_inherits(App,_Component);var _super=_createSuper(App);function App(props){var _this;_classCallCheck(this,App);_this=_super.call(this,props);// Define player representations\n_this.handleConfirm=function(){_this.endTurn();_this.setState({isModalOpen:false});};_this.handleCancel=function(){_this.setState({isModalOpen:false,isModalShownThisTurn:true});};_this.handleReset=function(){window.location.reload();};_this.players=[{id:0,name:\"Player 0\",color:\"grey\",shape:\"circle\",points:0,score:0},{id:1,name:\"Player 1\",color:\"blue\",shape:\"circle\",points:0,score:0},{id:2,name:\"Player 2\",color:\"red\",shape:\"circle\",points:0,score:0}];// Create hexagons and assign them to players\nvar hexagons=GridGenerator.hexagon(3).map(function(hex){return _objectSpread(_objectSpread({},hex),{},{//owner: Math.random() < 0.5 ? 1 : 2, // Assign to player 1 or 2 - MODE 1 RANDOM\nowner:hex.r===-3?1:hex.r===3?2:0,// Assign ownership based on row number - MAIN MODE\n//hasUnit: Math.random() < 0.2, // Adjust the probability as needed - MODE 1 RANDOM\nhasUnit:hex.r===-3?true:hex.r===3?true:false,// Assign ownership based on row number - MAIN MODE\nmoved:false,attack:false,pushed:null,adjacent:null,count:0});});_this.state={hexagons:hexagons,path:{start:null,end:null},highlightedHexagons:[],currentPlayer:_this.players[1],// Start with the first player\nselectedUnit:null,selectedUnitPosition:null,selectedHex:null,isModalOpen:false,isModalShownThisTurn:false,// Track if the modal was shown this turn\ndisplayMode:'score'//default display mode\n};return _this;}_createClass(App,[{key:\"onClick\",value:function onClick(event,source){var _this$state=this.state,path=_this$state.path,hexagons=_this$state.hexagons,selectedUnit=_this$state.selectedUnit,currentPlayer=_this$state.currentPlayer,selectedHex=_this$state.selectedHex;var targetHex=source.state.hex;// Clear previous path or selection\nif(path.start==null){path.start=source.state.hex;}else{path.start=null;path.end=null;}var clickedHex=hexagons.find(function(hex){return HexUtils.equals(hex,targetHex);});var isUnitHex=clickedHex&&clickedHex.hasUnit;this.setState({selectedHex:null});// Movement Logic\nif(isUnitHex&&clickedHex.owner===currentPlayer.id){// If the clicked hexagon has a unit and the unit belongs to the current player\nthis.setState({selectedHex:clickedHex});if(!clickedHex.moved){this.setState({selectedUnit:clickedHex,selectedUnitPosition:targetHex});}else{this.setState({selectedUnit:clickedHex,selectedUnitPosition:targetHex});}}else if(selectedUnit&&this.isHighlightedHex(targetHex)&&!clickedHex.hasUnit){// If a unit is selected and a highlighted hexagon is clicked, move the unit or attack\nthis.moveUnit(selectedUnit,targetHex);this.setState({selectedHex:clickedHex});}else if(this.isHighlightedHex(targetHex)){this.moveUnit(selectedHex,clickedHex);}// Highlight Controller\nif(!clickedHex.moved&&clickedHex.owner===currentPlayer.id){// Calculate highlighted hexagons that are exactly 2 hexagon distances away only if it's a unit hex\nvar highlightedHexagons=isUnitHex?hexagons.filter(function(hex){var distance=HexUtils.distance(targetHex,hex);return distance<=2&&!hex.hasUnit;}):[];this.setState({path:path,highlightedHexagons:highlightedHexagons});}else{this.setState({path:path,highlightedHexagons:[]});}if(clickedHex.moved&&!clickedHex.attack&&clickedHex.hasUnit&&clickedHex.adjacent){// Calculate highlighted hexagons that are exactly 1 hexagon distance away only if it's a unit hex\nthis.highlightAttackableTiles(targetHex,currentPlayer,hexagons);}// OnClick Adjacent Logic: Highlight tiles for movement and attack\nif(isUnitHex&&!clickedHex.moved&&clickedHex.owner===currentPlayer.id){var adjacentEnemyHexagons=hexagons.filter(function(hex){var distance=HexUtils.distance(targetHex,hex);return distance===1&&hex.hasUnit&&hex.owner!==currentPlayer.id;});if(adjacentEnemyHexagons.length>0){var _highlightedHexagons=hexagons.filter(function(hex){var distance=HexUtils.distance(targetHex,hex);return distance===1&&(hex.hasUnit&&hex.owner)!==currentPlayer.id;});// Check if there is a unit behind the target hexagon that can be pushed\nvar hasPushableUnit=_highlightedHexagons.filter(function(hex){var direction={q:hex.q-targetHex.q,r:hex.r-targetHex.r,s:hex.s-targetHex.s};// Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\nif(Math.abs(direction.q)<=1&&Math.abs(direction.r)<=1&&Math.abs(direction.s)<=1){var behindHex={q:hex.q+direction.q,r:hex.r+direction.r,s:hex.s+direction.s};// Find the hexagon at the behindHex position\nvar behindHexagon=hexagons.find(function(hex){return HexUtils.equals(hex,behindHex);});var pushUnit=hexagons.find(function(hex){return HexUtils.equals(hex,direction);});if(behindHexagon==undefined){return hex;}else if(!behindHexagon.hasUnit){return hex;}else if(!hex.hasUnit&&!behindHex.hasUnit){return hex;}}});this.setState({highlightedHexagons:hasPushableUnit});}else{var _highlightedHexagons2=hexagons.filter(function(hex){var distance=HexUtils.distance(targetHex,hex);return distance<=2&&!hex.hasUnit;});this.setState({path:path,highlightedHexagons:_highlightedHexagons2});}}}//on click ends\n// Highlights hexagons that can be attacked\n},{key:\"highlightAttackableTiles\",value:function highlightAttackableTiles(targetHex,currentPlayer,hexagons){var highlightedHexagons=hexagons.filter(function(hex){var distance=HexUtils.distance(targetHex,hex);return distance===1&&hex.hasUnit&&hex.owner!==currentPlayer.id;});// Check if there is a unit behind the target hexagon that can be pushed\nvar hasPushableUnit=highlightedHexagons.filter(function(hex){var direction={q:hex.q-targetHex.q,r:hex.r-targetHex.r,s:hex.s-targetHex.s};// Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\nif(Math.abs(direction.q)<=1&&Math.abs(direction.r)<=1&&Math.abs(direction.s)<=1){var behindHex={q:hex.q+direction.q,r:hex.r+direction.r,s:hex.s+direction.s};// Find the hexagon at the behindHex position\nvar behindHexagon=hexagons.find(function(hex){return HexUtils.equals(hex,behindHex);});var pushUnit=hexagons.find(function(hex){return HexUtils.equals(hex,direction);});if(behindHexagon==undefined){return pushUnit;}else if(!behindHexagon.hasUnit){return pushUnit;}}});this.setState({highlightedHexagons:hasPushableUnit});}// Checks if a hexagon is highlighted\n},{key:\"isHighlightedHex\",value:function isHighlightedHex(hex){var highlightedHexagons=this.state.highlightedHexagons;return highlightedHexagons.some(function(highlightedHex){return HexUtils.equals(hex,highlightedHex);});}// Movement and Attack Mechanics\n},{key:\"moveUnit\",value:function moveUnit(unitHex,targetHex){var _this$state2=this.state,hexagons=_this$state2.hexagons,currentPlayer=_this$state2.currentPlayer,selectedUnit=_this$state2.selectedUnit,selectedHex=_this$state2.selectedHex;// If the selected unit has not moved yet, move it\nif(!unitHex.moved&&!targetHex.hasUnit){unitHex.hasUnit=false;// Update the target hexagon to have a unit and mark it as moved\nvar targetIndex=hexagons.findIndex(function(hex){return HexUtils.equals(hex,targetHex);});if(targetIndex!==-1){hexagons[targetIndex].hasUnit=true;hexagons[targetIndex].moved=true;hexagons[targetIndex].attack=false;hexagons[targetIndex].owner=currentPlayer.id;// Update the owner to the current player's id\n}}else{//Otherwise we can only push the unit\nthis.pushUnit(unitHex,targetHex,hexagons,currentPlayer);}this.setState({selectedUnit:null,selectedUnitPosition:null,hexagons:_toConsumableArray(hexagons),highlightedHexagons:[]});var updatedHexagons=checkSurroundedHexagons(this.state.hexagons);}// Calculate the direction for nudge animation\n},{key:\"calculateDirection\",value:function calculateDirection(sourceHex,targetHex){var qDiff=targetHex.q-sourceHex.q;var rDiff=targetHex.r-sourceHex.r;if(qDiff>0&&rDiff===0){return'East';}else if(qDiff<0&&rDiff===0){return'West';}else if(qDiff===0&&rDiff>0){return'SE';}else if(qDiff===0&&rDiff<0){return'NW';}else if(qDiff>0&&rDiff<0){return'NE';}else if(qDiff<0&&rDiff>0){return'SW';}// Handle other cases if needed\nreturn'unknown';}// PUSH LOGIC\n},{key:\"pushUnit\",value:function pushUnit(sourceHex,targetHex,hexagons,currentPlayer){var _this2=this;var sourceIndex=hexagons.findIndex(function(hex){return HexUtils.equals(hex,sourceHex);});var targetIndex=hexagons.findIndex(function(hex){return HexUtils.equals(hex,targetHex);});if(sourceIndex!==-1&&targetIndex!==-1){// Check if the target hex is empty\nif(hexagons[targetIndex].hasUnit){// Calculate the direction of the push\nvar direction={q:targetHex.q-sourceHex.q,r:targetHex.r-sourceHex.r,s:targetHex.s-sourceHex.s};// Calculate the new position for the target unit\nvar newTargetHex={q:targetHex.q+direction.q,r:targetHex.r+direction.r,s:targetHex.s+direction.s};var newTargetIndex=hexagons.findIndex(function(hex){return HexUtils.equals(hex,newTargetHex);});// Check if the target hex is outside the game board\nvar newTargetOutsideBoard=newTargetHex.q<-3||newTargetHex.q>3||newTargetHex.r<-3||newTargetHex.r>3||newTargetHex.s<-3||newTargetHex.s>3;if(newTargetIndex!==-1&&!hexagons[newTargetIndex].hasUnit){// Move the target unit to the new position\nhexagons[newTargetIndex].hasUnit=true;hexagons[newTargetIndex].moved=false;hexagons[newTargetIndex].attack=true;// or whatever the appropriate attack status is\nhexagons[newTargetIndex].owner=hexagons[targetIndex].owner;hexagons[newTargetIndex].count=hexagons[targetIndex].count+1;currentPlayer.score=currentPlayer.score+hexagons[targetIndex].count+1;// Clear the target hex\nhexagons[targetIndex].hasUnit=false;hexagons[targetIndex].moved=true;hexagons[targetIndex].attack=false;hexagons[targetIndex].count=null;// Update the owner to the current player's id\nhexagons[targetIndex].owner=0;//Update source unit so they can no longer push or move if push was successful\nsourceHex.attack=true;sourceHex.moved=true;// Clear the highlighted hexagons and selectedHex\nthis.setState({highlightedHexagons:[],selectedHex:null// Clear the selectedHex when a push occurs\n});// Calculate the direction for nudge animation target\nhexagons[newTargetIndex].pushed=this.calculateDirection(sourceHex,targetHex);// Calculate the direction for the nudge animation source\nsourceHex.pushed='s'+this.calculateDirection(sourceHex,targetHex);// Reset the pushed class after 500 milliseconds (adjust the duration as needed)\nsetTimeout(function(){hexagons[newTargetIndex].pushed=null;sourceHex.pushed=null;_this2.setState({hexagons:_toConsumableArray(hexagons)});// Update the state to re-render with the updated hexagons\n},500);// Adjust the duration (in milliseconds) as needed\n// Clear the highlighted hexagons\nthis.setState({selectedUnit:null,selectedUnitPosition:null,hexagons:_toConsumableArray(hexagons),highlightedHexagons:[]});}else if(newTargetOutsideBoard){//alert('Cannot push. Target position is outside board.');\n//removal + animation here\n//Update source unit so they can no longer push or move if push was successful\nsourceHex.attack=true;sourceHex.moved=true;// Calculate the direction for nudge animation target\nhexagons[targetIndex].pushed='f'+this.calculateDirection(sourceHex,targetHex);// Calculate the direction for the nudge animation source\nsourceHex.pushed='s'+this.calculateDirection(sourceHex,targetHex);// Reset the pushed class after 500 milliseconds (adjust the duration as needed)\nsetTimeout(function(){// Clear the target hex\nhexagons[targetIndex].hasUnit=false;hexagons[targetIndex].moved=true;hexagons[targetIndex].attack=false;hexagons[targetIndex].pushed=null;sourceHex.pushed=null;if(!hexagons[targetIndex].count){hexagons[targetIndex].count=2;}else hexagons[targetIndex].count=hexagons[targetIndex].count*2;currentPlayer.score=currentPlayer.score+hexagons[targetIndex].count;// Update the owner to the current player's id\nhexagons[targetIndex].owner=0;var updatedHexagons=checkSurroundedHexagons(_this2.state.hexagons);// included here because it is not working under the move function when pushed off the edge\n_this2.setState({hexagons:_toConsumableArray(hexagons)});// Update the state to re-render with the updated hexagons\n},1000);// Adjust the duration (in milliseconds) as needed\n// Clear the highlighted hexagons\nthis.setState({selectedUnit:null,selectedUnitPosition:null,hexagons:_toConsumableArray(hexagons),highlightedHexagons:[]});}else{alert('Cannot push. Target position is occupied');}}}}// Function to check if the current player has any valid moves or attacks\n},{key:\"hasValidActions\",value:function hasValidActions(){var _this$state3=this.state,hexagons=_this$state3.hexagons,players=_this$state3.players,currentPlayer=_this$state3.currentPlayer;var playerTileCounts={};// Calculate the tile count for each player\nhexagons.forEach(function(hex){var owner=hex.owner;if(owner!==null){if(!playerTileCounts[owner]){playerTileCounts[owner]=0;}playerTileCounts[owner]++;}});currentPlayer.points=playerTileCounts[currentPlayer.id]+currentPlayer.score;var hasVictory=currentPlayer.points>=40;// Check if the currentPlayer has any valid moves or attacks\nvar hasValidMoves=hexagons.some(function(hex){return hex.owner===currentPlayer.id&&hex.hasUnit&&!hex.moved;});// Check if the currentPlayer has any valid attacks\nvar hasValidAttacks=hexagons.some(function(hex){return hex.owner===currentPlayer.id&&hex.hasUnit&&!hex.attack&&hex.adjacent;});if(hasVictory){return false;}else return hasValidMoves||hasValidAttacks||hasVictory;}},{key:\"endTurn\",value:// Ends the current player's turn\nfunction endTurn(){var _this$state4=this.state,currentPlayer=_this$state4.currentPlayer,hexagons=_this$state4.hexagons;var playerScore=calculatePlayerScore(currentPlayer,hexagons);var updatedPlayers=updatePlayerScore(this.players,currentPlayer,playerScore);// Update this.players (if needed) no longer using\n// this.players = updatedPlayers;\nif(checkVictoryCondition(currentPlayer,playerScore)){alert(\"\".concat(currentPlayer.name,\" wins with a score of \").concat(currentPlayer.score+playerScore,\"!\"));// Handle game reset or victory actions here\n}else{// ... rest of the function\n}var currentPlayerIndex=this.players.findIndex(function(player){return player.id===currentPlayer.id;});var nextPlayerIndex=findNextPlayerIndex(currentPlayerIndex,this.players);this.setState({selectedUnit:null,selectedUnitPosition:null,highlightedHexagons:[],isModalShownThisTurn:false,currentPlayer:this.players[nextPlayerIndex]});// Assuming hexagons is part of your component's state\nvar updatedHexagons=resetMovedUnits(this.state.hexagons);// Set the state with the updated hexagons\nthis.setState({hexagons:updatedHexagons});}},{key:\"renderPlayerStats\",value:function renderPlayerStats(){var _this3=this;var _this$state5=this.state,hexagons=_this$state5.hexagons,currentPlayer=_this$state5.currentPlayer,players=_this$state5.players,displayMode=_this$state5.displayMode;var playerTileCounts={};// Calculate the tile count for each player\nhexagons.forEach(function(hex){var owner=hex.owner;if(owner!==null){if(!playerTileCounts[owner]){playerTileCounts[owner]=0;}playerTileCounts[owner]++;}});return/*#__PURE__*/ (// Render the tile count for each player within a HexGrid layout\n_jsxs(HexGrid,{width:300,height:130,viewBox:\"-60 -55 120 120\",children:[/*#__PURE__*/_jsx(Layout,{size:{x:48,y:48},flat:false,spacing:1.1,origin:{x:0,y:0},children:this.players.map(function(player){var qValue;if(player.id===0){qValue=0;// Position player 0's hexagon in the center\n}else if(player.id===1){qValue=-1;// Position player 1's hexagon to the left\n}else{qValue=1;// Position player 2's hexagon to the right\n}var isCurrentPlayer=player.id===currentPlayer.id;// Check if this is the current player\nreturn/*#__PURE__*/_jsx(Hexagon,{q:qValue,r:0,s:-qValue,owner:player.id,className:\"score \".concat(isCurrentPlayer?'active':'')// Apply 'active' class for the current player\n,opacity:isCurrentPlayer?1.0:0.0// Set opacity based on whether it's the current player\n},player.id);})}),\"//this is just so the score text doesn't pulse:\",/*#__PURE__*/_jsx(Layout,{size:{x:44,y:44},flat:false,spacing:1.2,origin:{x:0,y:0},children:this.players.map(function(player){var qValue;if(player.id===0){qValue=0;// Position player 0's hexagon in the center\n}else if(player.id===1){qValue=-1;// Position player 1's hexagon to the left\n}else{qValue=1;// Position player 2's hexagon to the right\n}// Check if this is the current player\nvar isCurrentPlayer=player.id===currentPlayer.id;return/*#__PURE__*/_jsx(Hexagon,{q:qValue,r:0,s:-qValue,owner:player.id,className:\"score\"// Apply 'active' class for the current player\n,opacity:1,onClick:function onClick(){return _this3.toggleDisplayMode();},children:/*#__PURE__*/_jsx(Text,{className:\"score text \".concat(player.id===0?'player-0-text':''),style:player.id===0?{fontSize:'20px',fontWeight:'bold'}:{},children:player.id===0?displayMode==='score'?'SCORE':'COUNT':displayMode==='score'?\"\".concat(player.score+playerTileCounts[player.id]):\"\".concat(playerTileCounts[player.id]||0)})},player.id);})})]}));}// Add this function to toggle the display mode\n},{key:\"toggleDisplayMode\",value:function toggleDisplayMode(){this.setState(function(prevState){return{displayMode:prevState.displayMode==='score'?'tileCount':'score'};});}},{key:\"render\",value:function render(){var _this4=this;var _this$state6=this.state,isModalOpen=_this$state6.isModalOpen,isModalShownThisTurn=_this$state6.isModalShownThisTurn,hexagons=_this$state6.hexagons,path=_this$state6.path,highlightedHexagons=_this$state6.highlightedHexagons,selectedUnit=_this$state6.selectedUnit,selectedUnitPosition=_this$state6.selectedUnitPosition,currentPlayer=_this$state6.currentPlayer,selectedHex=_this$state6.selectedHex;// Check if the current player has any valid moves or attacks\nvar hasValidActions=this.hasValidActions();// Dynamically set the button's background color based on the current player's color\nvar buttonStyle={backgroundColor:currentPlayer.color};return/*#__PURE__*/_jsxs(\"div\",{className:\"App\",children:[/*#__PURE__*/_jsx(\"h2\",{}),this.renderPlayerStats(),\" \",/*#__PURE__*/_jsx(\"p\",{children:/*#__PURE__*/_jsx(\"button\",{style:buttonStyle,onClick:function onClick(){return _this4.endTurn();},children:\"End Turn?\"})}),/*#__PURE__*/_jsx(HexGrid,{width:900,height:800,viewBox:\"-45 -45 90 90\",children:/*#__PURE__*/_jsxs(Layout,{size:{x:7,y:7},flat:false,spacing:1.1,origin:{x:0,y:0},children:[hexagons.map(function(hex,i){return/*#__PURE__*/_jsxs(Hexagon,{q:hex.q,r:hex.r,s:hex.s,owner:hex.owner// Set the owner attribute based on the hexagon's owner\n,className:highlightedHexagons.includes(hex)?'active':(selectedHex===hex?'selected':'')+(hex.pushed?hex.pushed:'')// Apply 'pushed' class if hexagon is pushed\n,onClick:function onClick(e,h){return _this4.onClick(e,h);},children:[hex.hasUnit&&/*#__PURE__*/_jsx(ShapeRenderer,{shape:_this4.players[hex.owner-1].shape// Use the player's shape based on the owner\n,fillOpacity:hex.moved&&hex.attack?'0.5':'1.0'}),!hex.attack&&hex.hasUnit&&(!hex.moved||hex.adjacent)&&/*#__PURE__*/_jsx(ShapeAnimator,{shape:_this4.players[hex.owner-1].shape// Use the player's shape based on the owner\n,fillOpacity:hex.moved===true?'0.5':'1.0',hex:hex,currentPlayer:currentPlayer}),hex.count&&!hex.pushed&&hex.owner!==currentPlayer&&/*#__PURE__*/_jsx(PointRenderer,{hex:hex,currentPlayer:currentPlayer})]},i);}),/*#__PURE__*/_jsx(Path,{start:path.start,end:path.end})]})}),selectedUnit&&/*#__PURE__*/_jsxs(\"p\",{children:[\"Selected Unit: \",HexUtils.getID(selectedUnitPosition)]}),selectedHex&&/*#__PURE__*/_jsxs(\"p\",{children:[\"Selected Hex: \",HexUtils.getID(selectedHex)]}),isModalShownThisTurn||hasValidActions?true:/*#__PURE__*/_jsx(ConfirmationModal,{hexagons:this.hexagons,players:this.players,currentPlayer:currentPlayer,isOpen:true// Always open the modal when there are no valid actions\n,onReset:function onReset(){return _this4.handleReset();},onCancel:function onCancel(){return _this4.handleCancel();},onConfirm:function onConfirm(){return _this4.handleConfirm();}})]});}}]);return App;}(Component);var PointRenderer=/*#__PURE__*/function(_React$Component){_inherits(PointRenderer,_React$Component);var _super2=_createSuper(PointRenderer);function PointRenderer(){_classCallCheck(this,PointRenderer);return _super2.apply(this,arguments);}_createClass(PointRenderer,[{key:\"render\",value:function render(){var _this$props=this.props,hex=_this$props.hex,shape=_this$props.shape,fill=_this$props.fill,fillOpacity=_this$props.fillOpacity,className=_this$props.className,currentPlayer=_this$props.currentPlayer;return/*#__PURE__*/_jsxs(\"text\",{className:\"push-animation\",x:\"-0.5em\",y:\"-0.5em\",children:[\"+\",hex.count]});return null;}}]);return PointRenderer;}(React.Component);var ShapeRenderer=/*#__PURE__*/function(_React$Component2){_inherits(ShapeRenderer,_React$Component2);var _super3=_createSuper(ShapeRenderer);function ShapeRenderer(){_classCallCheck(this,ShapeRenderer);return _super3.apply(this,arguments);}_createClass(ShapeRenderer,[{key:\"render\",value:function render(){var _this$props2=this.props,shape=_this$props2.shape,fill=_this$props2.fill,fillOpacity=_this$props2.fillOpacity,className=_this$props2.className;if(shape===\"circle\"){return/*#__PURE__*/_jsx(\"circle\",{cx:\"0\",cy:\"0\",r:\"1\",fill:fill,fillOpacity:fillOpacity,className:className,children:\";\"});}return null;}}]);return ShapeRenderer;}(React.Component);var ShapeAnimator=/*#__PURE__*/function(_React$Component3){_inherits(ShapeAnimator,_React$Component3);var _super4=_createSuper(ShapeAnimator);function ShapeAnimator(){_classCallCheck(this,ShapeAnimator);return _super4.apply(this,arguments);}_createClass(ShapeAnimator,[{key:\"shouldAnimate\",value:function shouldAnimate(){var _this$props3=this.props,hex=_this$props3.hex,currentPlayer=_this$props3.currentPlayer;return hex.owner===currentPlayer.id;}},{key:\"render\",value:function render(){var _this$props4=this.props,shape=_this$props4.shape,fill=_this$props4.fill,fillOpacity=_this$props4.fillOpacity,className=_this$props4.className;if(shape===\"circle\"){return/*#__PURE__*/_jsxs(\"circle\",{cx:\"0\",cy:\"0\",r:\"1\",fill:fill,fillOpacity:fillOpacity,className:className,children:[\";\",this.shouldAnimate()&&/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsx(\"animate\",{attributeName:\"r\",from:\"1\",to:\"2\",dur:\"1.5s\",begin:\"0s\",repeatCount:\"indefinite\"}),/*#__PURE__*/_jsx(\"animate\",{attributeName:\"opacity\",from:\"1\",to:\"0\",dur:\"1.5s\",begin:\"0s\",repeatCount:\"indefinite\"})]})]});}return null;}}]);return ShapeAnimator;}(React.Component);// Reset Animations on Click - needs some work - does this even do anything?\ndocument.addEventListener('click',function(){var animatedElements=document.querySelectorAll('.hexagon');// Add a class to pause animations\nanimatedElements.forEach(function(element){element.style.animation='none';// Set animation to an empty string\n});// After 10 ms, remove the class to resume animations\nsetTimeout(function(){animatedElements.forEach(function(element){element.style.animation='';// Set animation to an empty string\n});},10);});export default App;","map":{"version":3,"names":["React","Component","GridGenerator","HexGrid","Layout","Path","Text","Hexagon","HexUtils","ConfirmationModal","calculatePlayerScore","updatePlayerScore","checkVictoryCondition","findNextPlayerIndex","resetMovedUnits","checkSurroundedHexagons","jsx","_jsx","jsxs","_jsxs","Fragment","_Fragment","App","_Component","_inherits","_super","_createSuper","props","_this","_classCallCheck","call","handleConfirm","endTurn","setState","isModalOpen","handleCancel","isModalShownThisTurn","handleReset","window","location","reload","players","id","name","color","shape","points","score","hexagons","hexagon","map","hex","_objectSpread","owner","r","hasUnit","moved","attack","pushed","adjacent","count","state","path","start","end","highlightedHexagons","currentPlayer","selectedUnit","selectedUnitPosition","selectedHex","displayMode","_createClass","key","value","onClick","event","source","_this$state","targetHex","clickedHex","find","equals","isUnitHex","isHighlightedHex","moveUnit","filter","distance","highlightAttackableTiles","adjacentEnemyHexagons","length","hasPushableUnit","direction","q","s","Math","abs","behindHex","behindHexagon","pushUnit","undefined","some","highlightedHex","unitHex","_this$state2","targetIndex","findIndex","_toConsumableArray","updatedHexagons","calculateDirection","sourceHex","qDiff","rDiff","_this2","sourceIndex","newTargetHex","newTargetIndex","newTargetOutsideBoard","setTimeout","alert","hasValidActions","_this$state3","playerTileCounts","forEach","hasVictory","hasValidMoves","hasValidAttacks","_this$state4","playerScore","updatedPlayers","concat","currentPlayerIndex","player","nextPlayerIndex","renderPlayerStats","_this3","_this$state5","width","height","viewBox","children","size","x","y","flat","spacing","origin","qValue","isCurrentPlayer","className","opacity","toggleDisplayMode","style","fontSize","fontWeight","prevState","render","_this4","_this$state6","buttonStyle","backgroundColor","i","includes","e","h","ShapeRenderer","fillOpacity","ShapeAnimator","PointRenderer","getID","isOpen","onReset","onCancel","onConfirm","_React$Component","_super2","apply","arguments","_this$props","fill","_React$Component2","_super3","_this$props2","cx","cy","_React$Component3","_super4","shouldAnimate","_this$props3","_this$props4","attributeName","from","to","dur","begin","repeatCount","document","addEventListener","animatedElements","querySelectorAll","element","animation"],"sources":["C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/src/HexagonalGrid.js"],"sourcesContent":["/* src/HexagonalGrid.js */\r\n\r\nimport React, { Component } from 'react';\r\nimport { GridGenerator, HexGrid, Layout, Path, Text, Hexagon, HexUtils } from 'react-hexgrid';\r\nimport './App.css';\r\nimport ConfirmationModal from './ConfirmationModal'; // Import the ConfirmationModal component\r\nimport { calculatePlayerScore, updatePlayerScore, checkVictoryCondition, findNextPlayerIndex, resetMovedUnits, checkSurroundedHexagons} from './GameLogic';\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // Define player representations\r\nthis.players = [\r\n  { id: 0, name: \"Player 0\", color: \"grey\", shape: \"circle\", points: 0, score: 0 },\r\n  { id: 1, name: \"Player 1\", color: \"blue\", shape: \"circle\", points: 0, score: 0 },\r\n  { id: 2, name: \"Player 2\", color: \"red\", shape: \"circle\",  points: 0,  score: 0 },\r\n];\r\n    \r\n    // Create hexagons and assign them to players\r\n    const hexagons = GridGenerator.hexagon(3).map(hex => ({\r\n      ...hex,\r\n      //owner: Math.random() < 0.5 ? 1 : 2, // Assign to player 1 or 2 - MODE 1 RANDOM\r\n\t  owner: hex.r === -3 ? 1 : hex.r === 3 ? 2 : 0, // Assign ownership based on row number - MAIN MODE\r\n      //hasUnit: Math.random() < 0.2, // Adjust the probability as needed - MODE 1 RANDOM\r\n\t  hasUnit: hex.r === -3 ? true : hex.r === 3 ? true : false, // Assign ownership based on row number - MAIN MODE\r\n      moved: false,\r\n      attack: false,\r\n\t  pushed: null,\r\n\t  adjacent: null,\r\n\t  count: 0,\r\n    }));\r\n\r\n    this.state = {\r\n      hexagons,\r\n      path: { start: null, end: null },\r\n      highlightedHexagons: [],\r\n      currentPlayer: this.players[1], // Start with the first player\r\n      selectedUnit: null,\r\n      selectedUnitPosition: null,\r\n      selectedHex: null,\r\n\t  isModalOpen: false,\r\n      isModalShownThisTurn: false,  // Track if the modal was shown this turn\r\n\t  displayMode: 'score', //default display mode\r\n    };\r\n  }\r\n\r\n\r\n\r\n  onClick(event, source) {\r\n    const { path, hexagons, selectedUnit, currentPlayer, selectedHex} = this.state;\r\n    const targetHex = source.state.hex;\r\n\t\r\n\t\r\n    // Clear previous path or selection\r\n    if (path.start == null) {\r\n      path.start = source.state.hex;\r\n    } else {\r\n      path.start = null;\r\n      path.end = null;\r\n    }\r\n\t\t\t\t\r\n\t\t\r\n    const clickedHex = hexagons.find(hex => HexUtils.equals(hex, targetHex));\r\n    const isUnitHex = clickedHex && clickedHex.hasUnit;\r\n\tthis.setState({ selectedHex: null});\r\n\r\n    // Movement Logic\r\n    if (isUnitHex && clickedHex.owner === currentPlayer.id) {\r\n      // If the clicked hexagon has a unit and the unit belongs to the current player\r\n\t  this.setState({ selectedHex: clickedHex });\r\n      if (!clickedHex.moved) {\r\n        this.setState({\r\n          selectedUnit: clickedHex,\r\n          selectedUnitPosition: targetHex,\r\n        });\r\n      } else {\r\n        this.setState({\r\n          selectedUnit: clickedHex,\r\n          selectedUnitPosition: targetHex,\r\n        });\r\n      }\r\n    } else if (selectedUnit && this.isHighlightedHex(targetHex) && !clickedHex.hasUnit ){\r\n      // If a unit is selected and a highlighted hexagon is clicked, move the unit or attack\r\n      this.moveUnit(selectedUnit, targetHex);\r\n\t  this.setState({ selectedHex: clickedHex});\r\n    } else if (this.isHighlightedHex(targetHex)) { \r\n      this.moveUnit(selectedHex, clickedHex);\r\n    }\r\n\r\n    // Highlight Controller\r\n    if (!clickedHex.moved && clickedHex.owner === currentPlayer.id) {\r\n      // Calculate highlighted hexagons that are exactly 2 hexagon distances away only if it's a unit hex\r\n      const highlightedHexagons = isUnitHex\r\n        ? hexagons.filter(hex => {\r\n          const distance = HexUtils.distance(targetHex, hex);\r\n          return distance <= 2 && !hex.hasUnit;\r\n        })\r\n        : [];\r\n      this.setState({ path, highlightedHexagons });\r\n    } else {\r\n      this.setState({ path, highlightedHexagons: [] });\r\n    }\r\n\r\n    if (clickedHex.moved && !clickedHex.attack && clickedHex.hasUnit && clickedHex.adjacent) {\r\n      // Calculate highlighted hexagons that are exactly 1 hexagon distance away only if it's a unit hex\r\n      this.highlightAttackableTiles(targetHex, currentPlayer, hexagons);\r\n    }\r\n\t\r\n// OnClick Adjacent Logic: Highlight tiles for movement and attack\r\nif (isUnitHex && !clickedHex.moved && clickedHex.owner === currentPlayer.id) {\r\n  const adjacentEnemyHexagons = hexagons.filter(hex => {\r\n    const distance = HexUtils.distance(targetHex, hex);\r\n    return distance === 1 && hex.hasUnit && hex.owner !== currentPlayer.id;\r\n  });\r\n\r\n  if (adjacentEnemyHexagons.length > 0) {\r\n    const highlightedHexagons = hexagons.filter(hex => {\r\n      const distance = HexUtils.distance(targetHex, hex);\r\n      return distance === 1 && (hex.hasUnit && hex.owner) !== currentPlayer.id;\r\n    });\r\n\t\r\n\r\n\t\r\n\t  // Check if there is a unit behind the target hexagon that can be pushed\r\n  const hasPushableUnit = highlightedHexagons.filter(hex => {\r\n    const direction = {\r\n      q: hex.q - targetHex.q,\r\n      r: hex.r - targetHex.r,\r\n      s: hex.s - targetHex.s\r\n    };\r\n\t\r\n\t\r\n\t\r\n\t    // Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\r\n    if (Math.abs(direction.q) <= 1 && Math.abs(direction.r) <= 1 && Math.abs(direction.s) <= 1) {\r\n      const behindHex = {\r\n        q: hex.q + direction.q,\r\n        r: hex.r + direction.r,\r\n        s: hex.s + direction.s\r\n      };\r\n  \r\n      // Find the hexagon at the behindHex position\r\n      const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\r\n\t  \r\n\t  const pushUnit = hexagons.find(hex => HexUtils.equals(hex, direction));\r\n\t  \r\n\t\r\n\t  \r\n\t  if(behindHexagon == undefined){\r\n\t\t \r\n\t\t  return hex;\r\n\t  }\r\n\t   else if(!behindHexagon.hasUnit){  \r\n\t   \r\n\t\treturn hex;\r\n\t  } else if(!hex.hasUnit && !behindHex.hasUnit){\r\n\t\t\r\n\t\treturn hex;\r\n\t}\r\n    }\r\n\t\r\n\t});\r\n\r\n    this.setState({ highlightedHexagons : hasPushableUnit });\t\r\n\t\r\n\t\r\n  } else {\r\n    const highlightedHexagons = hexagons.filter(hex => {\r\n      const distance = HexUtils.distance(targetHex, hex);\r\n      return distance <= 2 && !hex.hasUnit;\r\n    });\r\n\r\n    this.setState({ path, highlightedHexagons });\r\n  }\r\n}\t\r\n  } //on click ends\r\n\r\n\r\n  \r\n  // Highlights hexagons that can be attacked\r\n  highlightAttackableTiles(targetHex, currentPlayer, hexagons) {\r\n    const highlightedHexagons = hexagons.filter(hex => {\r\n      const distance = HexUtils.distance(targetHex, hex);\r\n      return distance === 1 && hex.hasUnit && hex.owner !== currentPlayer.id;\r\n    });\r\n\r\n\t\r\n\t  // Check if there is a unit behind the target hexagon that can be pushed\r\n  const hasPushableUnit = highlightedHexagons.filter(hex => {\r\n    const direction = {\r\n      q: hex.q - targetHex.q,\r\n      r: hex.r - targetHex.r,\r\n      s: hex.s - targetHex.s\r\n    };\r\n\t    // Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\r\n    if (Math.abs(direction.q) <= 1 && Math.abs(direction.r) <= 1 && Math.abs(direction.s) <= 1) {\r\n      const behindHex = {\r\n        q: hex.q + direction.q,\r\n        r: hex.r + direction.r,\r\n        s: hex.s + direction.s\r\n      };\r\n  \r\n      // Find the hexagon at the behindHex position\r\n      const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\r\n\t  \r\n\t  const pushUnit = hexagons.find(hex => HexUtils.equals(hex, direction));\r\n\t  \r\n\t  if(behindHexagon == undefined){\r\n\t\t  return pushUnit;\r\n\t  }\r\n\t   else if(!behindHexagon.hasUnit){  \r\n\t\treturn pushUnit;\r\n\t  } \r\n    }\t\t\r\n\t});\r\n\r\n    this.setState({ highlightedHexagons : hasPushableUnit });\t\r\n\t\r\n  }\r\n  \r\n\r\n  // Checks if a hexagon is highlighted\r\n  isHighlightedHex(hex) {\r\n    const { highlightedHexagons } = this.state;\r\n    return highlightedHexagons.some(highlightedHex => HexUtils.equals(hex, highlightedHex));\r\n  }\r\n  \r\n  // Movement and Attack Mechanics\r\n  moveUnit(unitHex, targetHex) {\r\n    const { hexagons, currentPlayer, selectedUnit, selectedHex } = this.state;\r\n\t\r\n    // If the selected unit has not moved yet, move it\r\n    if (!unitHex.moved && !targetHex.hasUnit ) {\r\n      unitHex.hasUnit = false;\r\n      \r\n      // Update the target hexagon to have a unit and mark it as moved\r\n      const targetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, targetHex));\r\n      if (targetIndex !== -1) {\r\n        hexagons[targetIndex].hasUnit = true;\r\n        hexagons[targetIndex].moved = true;\r\n        hexagons[targetIndex].attack = false;\r\n        hexagons[targetIndex].owner = currentPlayer.id; // Update the owner to the current player's id\r\n      }\r\n    }  else{ //Otherwise we can only push the unit\r\n\t\t\r\n      this.pushUnit(unitHex, targetHex, hexagons, currentPlayer);\r\n\t  \r\n\r\n\t}\r\n    this.setState({\r\n      selectedUnit: null,\r\n      selectedUnitPosition: null,\r\n      hexagons: [...hexagons],\r\n      highlightedHexagons: [],\r\n    });\r\n\t\r\n\tconst updatedHexagons = checkSurroundedHexagons(this.state.hexagons);\t \r\n  }\r\n \r\n// Calculate the direction for nudge animation\r\ncalculateDirection(sourceHex, targetHex) {\r\n  const qDiff = targetHex.q - sourceHex.q;\r\n  const rDiff = targetHex.r - sourceHex.r;\r\n\r\n  if (qDiff > 0 && rDiff === 0) {\r\n    return 'East';\r\n  } else if (qDiff < 0 && rDiff === 0) {\r\n    return 'West';\r\n  } else if (qDiff === 0 && rDiff > 0) {\r\n    return 'SE';\r\n  } else if (qDiff === 0 && rDiff < 0) {\r\n    return 'NW';\r\n  } else if (qDiff > 0 && rDiff < 0) {\r\n    return 'NE';\r\n  } else if (qDiff < 0 && rDiff > 0) {\r\n    return 'SW';\r\n  }\r\n\r\n  // Handle other cases if needed\r\n\r\n  return 'unknown';\r\n}\r\n\r\n \r\n// PUSH LOGIC\r\npushUnit(sourceHex, targetHex, hexagons, currentPlayer) {\r\n  const sourceIndex = hexagons.findIndex(hex => HexUtils.equals(hex, sourceHex));\r\n  const targetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, targetHex));\r\n  \r\n\r\n  if (sourceIndex !== -1 && targetIndex !== -1) {\r\n    // Check if the target hex is empty\r\n    if (hexagons[targetIndex].hasUnit) {\r\n      // Calculate the direction of the push\r\n      const direction = {\r\n        q: targetHex.q - sourceHex.q,\r\n        r: targetHex.r - sourceHex.r,\r\n        s: targetHex.s - sourceHex.s\r\n      };\r\n\r\n      // Calculate the new position for the target unit\r\n      const newTargetHex = {\r\n        q: targetHex.q + direction.q,\r\n        r: targetHex.r + direction.r,\r\n        s: targetHex.s + direction.s\r\n      };\r\n\r\n\t\tconst newTargetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, newTargetHex));\r\n\t  \r\n\t      // Check if the target hex is outside the game board\r\n\t\tconst newTargetOutsideBoard = newTargetHex.q < -3 || newTargetHex.q > 3 || newTargetHex.r < -3 || newTargetHex.r > 3 || newTargetHex.s < -3 || newTargetHex.s > 3;\r\n  \r\n\r\n\r\n      if (newTargetIndex !== -1 && !hexagons[newTargetIndex].hasUnit) {\r\n        // Move the target unit to the new position\r\n        hexagons[newTargetIndex].hasUnit = true;\r\n        hexagons[newTargetIndex].moved = false;\r\n        hexagons[newTargetIndex].attack = true; // or whatever the appropriate attack status is\r\n        hexagons[newTargetIndex].owner = hexagons[targetIndex].owner;\r\n\t\thexagons[newTargetIndex].count = hexagons[targetIndex].count + 1;\r\n\t\tcurrentPlayer.score = currentPlayer.score + hexagons[targetIndex].count + 1;\r\n\t\r\n\r\n        // Clear the target hex\r\n        hexagons[targetIndex].hasUnit = false;\r\n        hexagons[targetIndex].moved = true;\r\n        hexagons[targetIndex].attack = false;\r\n\t\thexagons[targetIndex].count = null;\r\n\r\n        // Update the owner to the current player's id\r\n        hexagons[targetIndex].owner = 0;\r\n\t\t\r\n\t\t//Update source unit so they can no longer push or move if push was successful\r\n\t\tsourceHex.attack = true;\r\n\t\tsourceHex.moved = true;\r\n\t\r\n\r\n    // Clear the highlighted hexagons and selectedHex\r\n    this.setState({\r\n      highlightedHexagons: [],\r\n      selectedHex: null  // Clear the selectedHex when a push occurs\r\n    });\r\n\t\r\n  // Calculate the direction for nudge animation target\r\nhexagons[newTargetIndex].pushed = this.calculateDirection(sourceHex, targetHex);\r\n\r\n// Calculate the direction for the nudge animation source\r\nsourceHex.pushed = 's' + this.calculateDirection(sourceHex, targetHex);\r\n \r\n\r\n// Reset the pushed class after 500 milliseconds (adjust the duration as needed)\r\nsetTimeout(() => {\r\n\t\r\n\thexagons[newTargetIndex].pushed = null;\r\n\tsourceHex.pushed = null;\r\n\tthis.setState({ hexagons: [...hexagons] }); // Update the state to re-render with the updated hexagons\r\n}, 500); // Adjust the duration (in milliseconds) as needed\r\n\t\t\t\r\n        // Clear the highlighted hexagons\r\n        this.setState({\r\n          selectedUnit: null,\r\n          selectedUnitPosition: null,\r\n          hexagons: [...hexagons],\r\n          highlightedHexagons: [],\r\n        });\r\n\t\t\r\n\t\t\r\n      } else if (newTargetOutsideBoard) {\r\n\t\t//alert('Cannot push. Target position is outside board.');\r\n\t\t\r\n\t\t//removal + animation here\r\n\r\n\t\t\r\n\t\t//Update source unit so they can no longer push or move if push was successful\r\n\t\tsourceHex.attack = true;\r\n\t\tsourceHex.moved = true;\r\n\r\n  // Calculate the direction for nudge animation target\r\nhexagons[targetIndex].pushed = 'f' + this.calculateDirection(sourceHex, targetHex);\t\t\r\n\t\t// Calculate the direction for the nudge animation source\r\nsourceHex.pushed = 's' + this.calculateDirection(sourceHex, targetHex);\r\n\t\t\r\n\t\t// Reset the pushed class after 500 milliseconds (adjust the duration as needed)\r\nsetTimeout(() => {\r\n\t\r\n\t\r\n\t\r\n\t\t        // Clear the target hex\r\n        hexagons[targetIndex].hasUnit = false;\r\n        hexagons[targetIndex].moved = true;\r\n        hexagons[targetIndex].attack = false;\r\n\t\r\n\thexagons[targetIndex].pushed = null;\r\n\tsourceHex.pushed = null;\r\n\t\r\n\tif(!hexagons[targetIndex].count){\r\n\t\thexagons[targetIndex].count = 2;\r\n\t} else hexagons[targetIndex].count = (hexagons[targetIndex].count)*2;\r\n\t\r\n\r\n\tcurrentPlayer.score = currentPlayer.score + hexagons[targetIndex].count;\r\n\r\n\t\r\n\t// Update the owner to the current player's id\r\n        hexagons[targetIndex].owner = 0;\r\n\tconst updatedHexagons = checkSurroundedHexagons(this.state.hexagons); // included here because it is not working under the move function when pushed off the edge\r\n\t\r\n\tthis.setState({ hexagons: [...hexagons] }); // Update the state to re-render with the updated hexagons\r\n}, 1000); // Adjust the duration (in milliseconds) as needed\r\n\t\t\t\r\n        // Clear the highlighted hexagons\r\n        this.setState({\r\n          selectedUnit: null,\r\n          selectedUnitPosition: null,\r\n          hexagons: [...hexagons],\r\n          highlightedHexagons: [],\r\n        });\r\n\t\t\t\r\n      } else {\r\n\t\talert('Cannot push. Target position is occupied');  \r\n\t  }\r\n    } \r\n  } \r\n}\r\n\r\n   // Function to check if the current player has any valid moves or attacks\r\nhasValidActions() {\r\n    const { hexagons, players, currentPlayer} = this.state;\r\n\t\r\n\t  const playerTileCounts = {};\r\n\r\n  // Calculate the tile count for each player\r\n  hexagons.forEach(hex => {\r\n    const owner = hex.owner;\r\n    if (owner !== null) {\r\n      if (!playerTileCounts[owner]) {\r\n        playerTileCounts[owner] = 0;\r\n      }\r\n      playerTileCounts[owner]++;\r\n    }\r\n  });\r\n\r\n currentPlayer.points = playerTileCounts[currentPlayer.id] + currentPlayer.score;\r\n\t\r\n\t\r\n\tconst hasVictory = currentPlayer.points >= 40;\r\n\r\n    // Check if the currentPlayer has any valid moves or attacks\r\n    const hasValidMoves = hexagons.some(hex => hex.owner === currentPlayer.id && hex.hasUnit && !hex.moved);\r\n\r\n    // Check if the currentPlayer has any valid attacks\r\n    const hasValidAttacks = hexagons.some(\r\n      hex =>\r\n        hex.owner === currentPlayer.id && hex.hasUnit &&\r\n        !hex.attack && hex.adjacent\r\n        \r\n    );\r\n\t\r\n\r\n\t\r\n\t\r\n      \r\n\r\n\tif(hasVictory) {\r\n\t\t\r\n\t\t\r\n\t\treturn false;\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t}else \r\n\t\t\r\n return hasValidMoves || hasValidAttacks || hasVictory;\r\n\r\n  }\r\n\r\n  handleConfirm = () => {\r\n    this.endTurn();\r\n    this.setState({ isModalOpen: false});\r\n  };\r\n\r\n  handleCancel = () => {\r\n    this.setState({ isModalOpen: false, isModalShownThisTurn: true });\r\n  };  \r\n  \r\n  \r\nhandleReset = () => {\r\n\t\r\nwindow.location.reload();\r\n\r\n  };\r\n\r\n  \r\n  \r\n  // Ends the current player's turn\r\nendTurn() {\r\n  const { currentPlayer, hexagons } = this.state;\r\n\r\n  const playerScore = calculatePlayerScore(currentPlayer, hexagons);\r\n  const updatedPlayers = updatePlayerScore(this.players, currentPlayer, playerScore);\r\n\r\n  // Update this.players (if needed) no longer using\r\n // this.players = updatedPlayers;\r\n\r\n  if (checkVictoryCondition(currentPlayer, playerScore)) { \r\n\t  \r\n\t  \r\n    alert(`${currentPlayer.name} wins with a score of ${currentPlayer.score + playerScore}!`);\r\n\t\r\n\t\r\n    // Handle game reset or victory actions here\r\n  } else {\r\n    // ... rest of the function\r\n  }\r\n\r\n  const currentPlayerIndex = this.players.findIndex(player => player.id === currentPlayer.id);\r\n  const nextPlayerIndex = findNextPlayerIndex(currentPlayerIndex, this.players);\r\n\r\n  this.setState({\r\n    selectedUnit: null,\r\n    selectedUnitPosition: null,\r\n    highlightedHexagons: [],\r\n    isModalShownThisTurn: false,\r\n    currentPlayer: this.players[nextPlayerIndex]\r\n  });\r\n  \r\n// Assuming hexagons is part of your component's state\r\nconst updatedHexagons = resetMovedUnits(this.state.hexagons);\r\n\r\n// Set the state with the updated hexagons\r\nthis.setState({ hexagons: updatedHexagons });\r\n}\r\n\r\n  \r\n\r\n  \r\nrenderPlayerStats() {\r\n  const { hexagons, currentPlayer, players, displayMode } = this.state;\r\n  const playerTileCounts = {};\r\n\r\n  // Calculate the tile count for each player\r\n  hexagons.forEach(hex => {\r\n    const owner = hex.owner;\r\n    if (owner !== null) {\r\n      if (!playerTileCounts[owner]) {\r\n        playerTileCounts[owner] = 0;\r\n      }\r\n      playerTileCounts[owner]++;\r\n    }\r\n  });\r\n\r\n \r\n\r\n  return (  // Render the tile count for each player within a HexGrid layout\r\n  \r\n    <HexGrid width={300} height={130} viewBox=\"-60 -55 120 120\">\r\n      <Layout size={{ x: 48, y: 48 }} flat={false} spacing={1.1} origin={{ x: 0, y: 0 }}>\r\n        {this.players.map(player => {\r\n          let qValue;\r\n          if (player.id === 0) {\r\n            qValue = 0; // Position player 0's hexagon in the center\r\n          } else if (player.id === 1) {\r\n            qValue = -1; // Position player 1's hexagon to the left\r\n          } else {\r\n            qValue = 1; // Position player 2's hexagon to the right\r\n          }\r\n\r\n          const isCurrentPlayer = player.id === currentPlayer.id;  // Check if this is the current player\r\n\t\t  \r\n          return (\r\n            <Hexagon\r\n              key={player.id}\r\n              q={qValue}\r\n              r={0}\r\n              s={-qValue}\r\n              owner={player.id}\r\n              className={`score ${isCurrentPlayer ? 'active' : ''}`}  // Apply 'active' class for the current player\r\n\t\t\t  opacity={isCurrentPlayer ? 1.0 : 0.0}  // Set opacity based on whether it's the current player\r\n            >\t\t\r\n            </Hexagon>\t\r\n          );\r\n        })}\r\n\t\t\r\n      </Layout>\r\n\t  \r\n\t  //this is just so the score text doesn't pulse:\r\n\t  <Layout size={{ x: 44, y: 44 }} flat={false} spacing={1.2} origin={{ x: 0, y: 0 }}>\r\n\t  {this.players.map(player => {\r\n          let qValue;\r\n          if (player.id === 0) {\r\n            qValue = 0; // Position player 0's hexagon in the center\r\n          } else if (player.id === 1) {\r\n            qValue = -1; // Position player 1's hexagon to the left\r\n          } else {\r\n            qValue = 1; // Position player 2's hexagon to the right\r\n          }\r\n\t\t            // Check if this is the current player\r\n          const isCurrentPlayer = player.id === currentPlayer.id;\r\n\t\t  \r\n          return (\r\n            <Hexagon\r\n              key={player.id}\r\n              q={qValue}\r\n              r={0}\r\n              s={-qValue}\r\n              owner={player.id}\r\n              className={\"score\"}  // Apply 'active' class for the current player\r\n\t\t\t  opacity={1}\r\n\t\t\t  onClick={() => this.toggleDisplayMode()}\r\n            >\r\n              <Text className={`score text ${player.id === 0 ? 'player-0-text' : ''}`} style={player.id === 0 ? { fontSize: '20px', fontWeight: 'bold' } : {}}>\r\n              {/*  {displayMode === 'score' ? `${playerTileCounts[player.id] || 0}` : `${player.score}`} just displays scores */}\r\n\t\t\t\t\r\n\t\t\t\t{player.id === 0 ? (displayMode === 'score' ? 'SCORE' : 'COUNT' ) : (displayMode === 'score' ?  `${player.score + playerTileCounts[player.id] }` :`${playerTileCounts[player.id] || 0}`)}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\r\n              </Text>\r\n\t\t\t  \r\n            </Hexagon>\r\n          );\r\n        })}\r\n\t  </Layout>\r\n    </HexGrid>\r\n\t\r\n\t\t\r\n\t\r\n  );\r\n}\r\n\r\n// Add this function to toggle the display mode\r\ntoggleDisplayMode() {\r\n  this.setState(prevState => ({\r\n    displayMode: prevState.displayMode === 'score' ? 'tileCount' : 'score',\r\n  }));\r\n}\r\n\r\n\r\n\r\n  render() {\r\n    const { isModalOpen, isModalShownThisTurn, hexagons, path, highlightedHexagons, selectedUnit, selectedUnitPosition, currentPlayer, selectedHex } = this.state;\r\n\t\r\n\t// Check if the current player has any valid moves or attacks\r\n    const hasValidActions = this.hasValidActions();\r\n\t\r\n\t\r\n\t // Dynamically set the button's background color based on the current player's color\r\n  const buttonStyle = {\r\n    backgroundColor: currentPlayer.color,\r\n  };\r\n\r\n\t\r\n    return (\r\n      <div className=\"App\">\r\n        <h2></h2>\r\n\t\t{this.renderPlayerStats()} {/* Render player tile counts */}  \r\n        {/* Update the button style to use the dynamic style */}\r\n      <p><button style={buttonStyle} onClick={() => this.endTurn()}>End Turn?</button></p>\r\n\t\t\r\n        <HexGrid width={900} height={800} viewBox=\"-45 -45 90 90\" >\r\n          <Layout size={{ x: 7, y: 7 }} flat={false} spacing={1.1} origin={{ x: 0, y: 0 }}>\r\n            {hexagons.map((hex, i) => (\r\n              <Hexagon\r\n                key={i}\r\n                q={hex.q}\r\n                r={hex.r}\r\n                s={hex.s}\r\n                owner={hex.owner} // Set the owner attribute based on the hexagon's owner\r\n                className={highlightedHexagons.includes(hex) ? 'active' : (selectedHex === hex ? 'selected' : '') + (hex.pushed ? hex.pushed : '')}  // Apply 'pushed' class if hexagon is pushed\r\n                onClick={(e, h) => this.onClick(e, h)}\r\n              >\r\n              {/*  <Text>{HexUtils.getID(hex)}</Text>  */}\r\n\t\t\t  {/*<Path start={path.start} end={selectedHex} /> //work on this to draw arrows*/}\r\n\t\t\t  \r\n\t\t\t  {/* ANIMATIONS HERE - still need to move CSS animations to function better */}\r\n\t\t\t  \r\n                {hex.hasUnit && (\r\n                  <ShapeRenderer\r\n                    shape={this.players[hex.owner - 1].shape} // Use the player's shape based on the owner\r\n\t\t\t\t\tfillOpacity={hex.moved && hex.attack  ? '0.5' : '1.0'}\t\t\t\t\t\t\r\n                  />\r\n                )}\r\n\t\t\t\t\r\n\t\t\t\t{!hex.attack && hex.hasUnit && (!hex.moved || hex.adjacent) && (\r\n\t\t\t\t <ShapeAnimator\r\n                    shape={this.players[hex.owner - 1].shape} // Use the player's shape based on the owner\r\n\t\t\t\t\tfillOpacity={hex.moved === true ? '0.5' : '1.0'}\t\r\n\t\t\t\t\thex={hex}\r\n\t\t\t\t\tcurrentPlayer={currentPlayer}\r\n                  />\r\n\t\t\t\t)} \r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t{hex.count && !hex.pushed && (hex.owner !== currentPlayer) && (\r\n                  <PointRenderer\r\n                    \thex={hex}\r\n\t\t\t\t\t\tcurrentPlayer={currentPlayer}\t\r\n                  />\r\n                )}\t\r\n\t\t\r\n\t\t\t {/* ANIMATIONS HERE - still need to move CSS animations to function better */}\r\n\t\t\t\r\n\t\t\t\r\n             </Hexagon>\r\n            ))}\r\n            <Path start={path.start} end={path.end} />\r\n          </Layout>\r\n        </HexGrid>\r\n        {selectedUnit && (\r\n          <p>Selected Unit: {HexUtils.getID(selectedUnitPosition)}</p>\r\n        )}\r\n        {selectedHex && (\r\n          <p>Selected Hex: {HexUtils.getID(selectedHex)}</p>\r\n        )}\r\n {/* Conditionally show the ConfirmationModal */}\r\n        { isModalShownThisTurn || hasValidActions ? true : (\r\n          <ConfirmationModal\r\n\t\t    hexagons={this.hexagons}\r\n\t\t    players={this.players}\r\n\t\t    currentPlayer = {currentPlayer}\r\n            isOpen={true} // Always open the modal when there are no valid actions\r\n\t\t\tonReset={() => this.handleReset()}\r\n            onCancel={() => this.handleCancel()}\r\n            onConfirm={() => this.handleConfirm()}\r\n          />\r\n        )}\r\n\r\n     </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nclass PointRenderer extends React.Component {\r\n\r\n  \r\n  render() {\r\n    const { hex, shape, fill, fillOpacity, className, currentPlayer } = this.props;\r\n\t\r\n    \r\n      return (      \r\n\t\t\r\n      <text\r\n        className=\"push-animation\"\r\n\t\t \r\n\t\t x=\"-0.5em\"\r\n\t\t y=\"-0.5em\" \r\n\t\t  \r\n      >\r\n        \r\n\t\t\r\n\r\n\t  +{hex.count}\r\n\t\t\r\n\t\t\r\n\t\t\r\n      </text>\r\n\t  );  \r\n    \r\n    return null;\r\n  }\r\n}\r\n\r\n\r\nclass ShapeRenderer extends React.Component {\r\n  render() {\r\n    const { shape, fill, fillOpacity, className } = this.props;\r\n    if (shape === \"circle\") {\r\n      return ( <circle cx=\"0\" cy=\"0\" r=\"1\" fill={fill} fillOpacity={fillOpacity}  className={className} >;\r\n\t  </circle>\r\n\t  );  \r\n    } \r\n    return null;\r\n  }\r\n}\r\n\r\n\r\n\r\nclass ShapeAnimator extends React.Component {\r\n  shouldAnimate() {\r\n    const { hex, currentPlayer } = this.props;\r\n    return hex.owner === currentPlayer.id;\r\n  }\t\r\n\t\r\n  render() {\r\n    const { shape, fill, fillOpacity, className } = this.props;\r\n    if (shape === \"circle\") {\r\n      return ( <circle cx=\"0\" cy=\"0\" r=\"1\" fill={fill} fillOpacity={fillOpacity}  className={className}>;\r\n          {this.shouldAnimate() && (\r\n            <>\r\n              <animate attributeName=\"r\" from=\"1\" to=\"2\" dur=\"1.5s\" begin=\"0s\" repeatCount=\"indefinite\" />\r\n              <animate attributeName=\"opacity\" from=\"1\" to=\"0\" dur=\"1.5s\" begin=\"0s\" repeatCount=\"indefinite\" />\r\n            </>\r\n          )}\r\n\t  </circle>\r\n\t  );\r\n    } \r\n    return null;\r\n  }\r\n}\r\n\r\n\r\n// Reset Animations on Click - needs some work - does this even do anything?\r\ndocument.addEventListener('click', function () {\r\n\t\r\n  const animatedElements = document.querySelectorAll('.hexagon');\r\n \r\n  // Add a class to pause animations\r\n  animatedElements.forEach(function (element) {\r\n    element.style.animation = 'none'; // Set animation to an empty string\r\n  });\r\n\r\n  // After 10 ms, remove the class to resume animations\r\n  setTimeout(function () {\r\n    animatedElements.forEach(function (element) {\r\n      element.style.animation = ''; // Set animation to an empty string\r\n    });\r\n  }, 10);\r\n});\r\n\r\nexport default App;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}