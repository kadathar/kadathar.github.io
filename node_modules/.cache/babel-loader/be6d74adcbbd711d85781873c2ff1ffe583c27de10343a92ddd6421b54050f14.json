{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\lokorasli\\\\Documents\\\\GitHub\\\\kadathar.github.io\\\\src\\\\HexagonalGrid.js\";\n/* src/HexagonalGrid.js */\n\nimport React, { Component } from 'react';\nimport { GridGenerator, HexGrid, Layout, Path, Text, Hexagon, HexUtils } from 'react-hexgrid';\nimport './App.css';\nimport ConfirmationModal from './ConfirmationModal'; // Import the ConfirmationModal component\nimport { calculatePlayerScore, updatePlayerScore, checkVictoryCondition, findNextPlayerIndex, resetMovedUnits, checkSurroundedHexagons } from './GameLogic';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nclass App extends Component {\n  constructor(props) {\n    super(props);\n\n    // Define player representations\n    this.handleConfirm = () => {\n      this.endTurn();\n      this.setState({\n        isModalOpen: false\n      });\n    };\n    this.handleCancel = () => {\n      this.setState({\n        isModalOpen: false,\n        isModalShownThisTurn: true\n      });\n    };\n    this.handleReset = () => {\n      window.location.reload();\n    };\n    this.players = [{\n      id: 0,\n      name: \"Player 0\",\n      color: \"grey\",\n      shape: \"circle\",\n      points: 0,\n      score: 0\n    }, {\n      id: 1,\n      name: \"Player 1\",\n      color: \"blue\",\n      shape: \"circle\",\n      points: 0,\n      score: 0\n    }, {\n      id: 2,\n      name: \"Player 2\",\n      color: \"red\",\n      shape: \"circle\",\n      points: 0,\n      score: 0\n    }];\n\n    // Create hexagons and assign them to players\n    const hexagons = GridGenerator.hexagon(3).map(hex => ({\n      ...hex,\n      //owner: Math.random() < 0.5 ? 1 : 2, // Assign to player 1 or 2 - MODE 1 RANDOM\n      owner: hex.r === -3 ? 1 : hex.r === 3 ? 2 : 0,\n      // Assign ownership based on row number - MAIN MODE\n      //hasUnit: Math.random() < 0.2, // Adjust the probability as needed - MODE 1 RANDOM\n      hasUnit: hex.r === -3 ? true : hex.r === 3 ? true : false,\n      // Assign ownership based on row number - MAIN MODE\n      moved: false,\n      attack: false,\n      pushed: null,\n      adjacent: null,\n      count: 0\n    }));\n    this.state = {\n      hexagons,\n      path: {\n        start: null,\n        end: null\n      },\n      highlightedHexagons: [],\n      currentPlayer: this.players[1],\n      // Start with the first player\n      selectedUnit: null,\n      selectedUnitPosition: null,\n      selectedHex: null,\n      isModalOpen: false,\n      isModalShownThisTurn: false,\n      // Track if the modal was shown this turn\n      displayMode: 'score' //default display mode\n    };\n  }\n\n  onClick(event, source) {\n    const {\n      path,\n      hexagons,\n      selectedUnit,\n      currentPlayer,\n      selectedHex\n    } = this.state;\n    const targetHex = source.state.hex;\n\n    // Clear previous path or selection\n    if (path.start == null) {\n      path.start = source.state.hex;\n    } else {\n      path.start = null;\n      path.end = null;\n    }\n    const clickedHex = hexagons.find(hex => HexUtils.equals(hex, targetHex));\n    const isUnitHex = clickedHex && clickedHex.hasUnit;\n    this.setState({\n      selectedHex: null\n    });\n\n    // Movement Logic\n    if (isUnitHex && clickedHex.owner === currentPlayer.id) {\n      // If the clicked hexagon has a unit and the unit belongs to the current player\n      this.setState({\n        selectedHex: clickedHex\n      });\n      if (!clickedHex.moved) {\n        this.setState({\n          selectedUnit: clickedHex,\n          selectedUnitPosition: targetHex\n        });\n      } else {\n        this.setState({\n          selectedUnit: clickedHex,\n          selectedUnitPosition: targetHex\n        });\n      }\n    } else if (selectedUnit && this.isHighlightedHex(targetHex) && !clickedHex.hasUnit) {\n      // If a unit is selected and a highlighted hexagon is clicked, move the unit or attack\n      this.moveUnit(selectedUnit, targetHex);\n      this.setState({\n        selectedHex: clickedHex\n      });\n    } else if (this.isHighlightedHex(targetHex)) {\n      this.moveUnit(selectedHex, clickedHex);\n    }\n\n    // Highlight Controller\n    if (!clickedHex.moved && clickedHex.owner === currentPlayer.id) {\n      // Calculate highlighted hexagons that are exactly 2 hexagon distances away only if it's a unit hex\n      const highlightedHexagons = isUnitHex ? hexagons.filter(hex => {\n        const distance = HexUtils.distance(targetHex, hex);\n        return distance <= 2 && !hex.hasUnit;\n      }) : [];\n      this.setState({\n        path,\n        highlightedHexagons\n      });\n    } else {\n      this.setState({\n        path,\n        highlightedHexagons: []\n      });\n    }\n    if (clickedHex.moved && !clickedHex.attack && clickedHex.hasUnit && clickedHex.adjacent) {\n      // Calculate highlighted hexagons that are exactly 1 hexagon distance away only if it's a unit hex\n      this.highlightAttackableTiles(targetHex, currentPlayer, hexagons);\n    }\n\n    // OnClick Adjacent Logic: Highlight tiles for movement and attack\n    if (isUnitHex && !clickedHex.moved && clickedHex.owner === currentPlayer.id) {\n      const adjacentEnemyHexagons = hexagons.filter(hex => {\n        const distance = HexUtils.distance(targetHex, hex);\n        return distance === 1 && hex.hasUnit && hex.owner !== currentPlayer.id;\n      });\n      if (adjacentEnemyHexagons.length > 0) {\n        const highlightedHexagons = hexagons.filter(hex => {\n          const distance = HexUtils.distance(targetHex, hex);\n          return distance === 1 && (hex.hasUnit && hex.owner) !== currentPlayer.id;\n        });\n\n        // Check if there is a unit behind the target hexagon that can be pushed\n        const hasPushableUnit = highlightedHexagons.filter(hex => {\n          const direction = {\n            q: hex.q - targetHex.q,\n            r: hex.r - targetHex.r,\n            s: hex.s - targetHex.s\n          };\n\n          // Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\n          if (Math.abs(direction.q) <= 1 && Math.abs(direction.r) <= 1 && Math.abs(direction.s) <= 1) {\n            const behindHex = {\n              q: hex.q + direction.q,\n              r: hex.r + direction.r,\n              s: hex.s + direction.s\n            };\n\n            // Find the hexagon at the behindHex position\n            const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\n            const pushUnit = hexagons.find(hex => HexUtils.equals(hex, direction));\n            if (behindHexagon == undefined) {\n              return hex;\n            } else if (!behindHexagon.hasUnit) {\n              return hex;\n            } else if (!hex.hasUnit && !behindHex.hasUnit) {\n              return hex;\n            }\n          }\n        });\n        this.setState({\n          highlightedHexagons: hasPushableUnit\n        });\n      } else {\n        const highlightedHexagons = hexagons.filter(hex => {\n          const distance = HexUtils.distance(targetHex, hex);\n          return distance <= 2 && !hex.hasUnit;\n        });\n        this.setState({\n          path,\n          highlightedHexagons\n        });\n      }\n    }\n  } //on click ends\n\n  // Highlights hexagons that can be attacked\n  highlightAttackableTiles(targetHex, currentPlayer, hexagons) {\n    const highlightedHexagons = hexagons.filter(hex => {\n      const distance = HexUtils.distance(targetHex, hex);\n      return distance === 1 && hex.hasUnit && hex.owner !== currentPlayer.id;\n    });\n\n    // Check if there is a unit behind the target hexagon that can be pushed\n    const hasPushableUnit = highlightedHexagons.filter(hex => {\n      const direction = {\n        q: hex.q - targetHex.q,\n        r: hex.r - targetHex.r,\n        s: hex.s - targetHex.s\n      };\n      // Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\n      if (Math.abs(direction.q) <= 1 && Math.abs(direction.r) <= 1 && Math.abs(direction.s) <= 1) {\n        const behindHex = {\n          q: hex.q + direction.q,\n          r: hex.r + direction.r,\n          s: hex.s + direction.s\n        };\n\n        // Find the hexagon at the behindHex position\n        const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\n        const pushUnit = hexagons.find(hex => HexUtils.equals(hex, direction));\n        if (behindHexagon == undefined) {\n          return pushUnit;\n        } else if (!behindHexagon.hasUnit) {\n          return pushUnit;\n        }\n      }\n    });\n    this.setState({\n      highlightedHexagons: hasPushableUnit\n    });\n  }\n\n  // Checks if a hexagon is highlighted\n  isHighlightedHex(hex) {\n    const {\n      highlightedHexagons\n    } = this.state;\n    return highlightedHexagons.some(highlightedHex => HexUtils.equals(hex, highlightedHex));\n  }\n\n  // Movement and Attack Mechanics\n  moveUnit(unitHex, targetHex) {\n    const {\n      hexagons,\n      currentPlayer,\n      selectedUnit,\n      selectedHex\n    } = this.state;\n\n    // If the selected unit has not moved yet, move it\n    if (!unitHex.moved && !targetHex.hasUnit) {\n      unitHex.hasUnit = false;\n\n      // Update the target hexagon to have a unit and mark it as moved\n      const targetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, targetHex));\n      if (targetIndex !== -1) {\n        hexagons[targetIndex].hasUnit = true;\n        hexagons[targetIndex].moved = true;\n        hexagons[targetIndex].attack = false;\n        hexagons[targetIndex].owner = currentPlayer.id; // Update the owner to the current player's id\n      }\n    } else {\n      //Otherwise we can only push the unit\n\n      this.pushUnit(unitHex, targetHex, hexagons, currentPlayer);\n    }\n    this.setState({\n      selectedUnit: null,\n      selectedUnitPosition: null,\n      hexagons: [...hexagons],\n      highlightedHexagons: []\n    });\n    const updatedHexagons = checkSurroundedHexagons(this.state.hexagons);\n  }\n\n  // Calculate the direction for nudge animation\n  calculateDirection(sourceHex, targetHex) {\n    const qDiff = targetHex.q - sourceHex.q;\n    const rDiff = targetHex.r - sourceHex.r;\n    if (qDiff > 0 && rDiff === 0) {\n      return 'East';\n    } else if (qDiff < 0 && rDiff === 0) {\n      return 'West';\n    } else if (qDiff === 0 && rDiff > 0) {\n      return 'SE';\n    } else if (qDiff === 0 && rDiff < 0) {\n      return 'NW';\n    } else if (qDiff > 0 && rDiff < 0) {\n      return 'NE';\n    } else if (qDiff < 0 && rDiff > 0) {\n      return 'SW';\n    }\n\n    // Handle other cases if needed\n\n    return 'unknown';\n  }\n\n  // PUSH LOGIC\n  pushUnit(sourceHex, targetHex, hexagons, currentPlayer) {\n    const sourceIndex = hexagons.findIndex(hex => HexUtils.equals(hex, sourceHex));\n    const targetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, targetHex));\n    if (sourceIndex !== -1 && targetIndex !== -1) {\n      // Check if the target hex is empty\n      if (hexagons[targetIndex].hasUnit) {\n        // Calculate the direction of the push\n        const direction = {\n          q: targetHex.q - sourceHex.q,\n          r: targetHex.r - sourceHex.r,\n          s: targetHex.s - sourceHex.s\n        };\n\n        // Calculate the new position for the target unit\n        const newTargetHex = {\n          q: targetHex.q + direction.q,\n          r: targetHex.r + direction.r,\n          s: targetHex.s + direction.s\n        };\n        const newTargetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, newTargetHex));\n\n        // Check if the target hex is outside the game board\n        const newTargetOutsideBoard = newTargetHex.q < -3 || newTargetHex.q > 3 || newTargetHex.r < -3 || newTargetHex.r > 3 || newTargetHex.s < -3 || newTargetHex.s > 3;\n        if (newTargetIndex !== -1 && !hexagons[newTargetIndex].hasUnit) {\n          // Move the target unit to the new position\n          hexagons[newTargetIndex].hasUnit = true;\n          hexagons[newTargetIndex].moved = false;\n          hexagons[newTargetIndex].attack = true; // or whatever the appropriate attack status is\n          hexagons[newTargetIndex].owner = hexagons[targetIndex].owner;\n          hexagons[newTargetIndex].count = hexagons[targetIndex].count + 1;\n          currentPlayer.score = currentPlayer.score + hexagons[targetIndex].count + 1;\n\n          // Clear the target hex\n          hexagons[targetIndex].hasUnit = false;\n          hexagons[targetIndex].moved = true;\n          hexagons[targetIndex].attack = false;\n          hexagons[targetIndex].count = null;\n\n          // Update the owner to the current player's id\n          hexagons[targetIndex].owner = 0;\n\n          //Update source unit so they can no longer push or move if push was successful\n          sourceHex.attack = true;\n          sourceHex.moved = true;\n\n          // Clear the highlighted hexagons and selectedHex\n          this.setState({\n            highlightedHexagons: [],\n            selectedHex: null // Clear the selectedHex when a push occurs\n          });\n\n          // Calculate the direction for nudge animation target\n          hexagons[newTargetIndex].pushed = this.calculateDirection(sourceHex, targetHex);\n\n          // Calculate the direction for the nudge animation source\n          sourceHex.pushed = 's' + this.calculateDirection(sourceHex, targetHex);\n\n          // Reset the pushed class after 500 milliseconds (adjust the duration as needed)\n          setTimeout(() => {\n            hexagons[newTargetIndex].pushed = null;\n            sourceHex.pushed = null;\n            this.setState({\n              hexagons: [...hexagons]\n            }); // Update the state to re-render with the updated hexagons\n          }, 500); // Adjust the duration (in milliseconds) as needed\n\n          // Clear the highlighted hexagons\n          this.setState({\n            selectedUnit: null,\n            selectedUnitPosition: null,\n            hexagons: [...hexagons],\n            highlightedHexagons: []\n          });\n        } else if (newTargetOutsideBoard) {\n          //alert('Cannot push. Target position is outside board.');\n\n          //removal + animation here\n\n          //Update source unit so they can no longer push or move if push was successful\n          sourceHex.attack = true;\n          sourceHex.moved = true;\n\n          // Calculate the direction for nudge animation target\n          hexagons[targetIndex].pushed = 'f' + this.calculateDirection(sourceHex, targetHex);\n          // Calculate the direction for the nudge animation source\n          sourceHex.pushed = 's' + this.calculateDirection(sourceHex, targetHex);\n\n          // Reset the pushed class after 500 milliseconds (adjust the duration as needed)\n          setTimeout(() => {\n            // Clear the target hex\n            hexagons[targetIndex].hasUnit = false;\n            hexagons[targetIndex].moved = true;\n            hexagons[targetIndex].attack = false;\n            hexagons[targetIndex].pushed = null;\n            sourceHex.pushed = null;\n            if (!hexagons[targetIndex].count) {\n              hexagons[targetIndex].count = 2;\n            } else hexagons[targetIndex].count = hexagons[targetIndex].count * 2;\n            currentPlayer.score = currentPlayer.score + hexagons[targetIndex].count;\n\n            // Update the owner to the current player's id\n            hexagons[targetIndex].owner = 0;\n            const updatedHexagons = checkSurroundedHexagons(this.state.hexagons); // included here because it is not working under the move function when pushed off the edge\n\n            this.setState({\n              hexagons: [...hexagons]\n            }); // Update the state to re-render with the updated hexagons\n          }, 1000); // Adjust the duration (in milliseconds) as needed\n\n          // Clear the highlighted hexagons\n          this.setState({\n            selectedUnit: null,\n            selectedUnitPosition: null,\n            hexagons: [...hexagons],\n            highlightedHexagons: []\n          });\n        } else {\n          alert('Cannot push. Target position is occupied');\n        }\n      }\n    }\n  }\n\n  // Function to check if the current player has any valid moves or attacks\n  hasValidActions() {\n    const {\n      hexagons,\n      players,\n      currentPlayer\n    } = this.state;\n    const playerTileCounts = {};\n\n    // Calculate the tile count for each player\n    hexagons.forEach(hex => {\n      const owner = hex.owner;\n      if (owner !== null) {\n        if (!playerTileCounts[owner]) {\n          playerTileCounts[owner] = 0;\n        }\n        playerTileCounts[owner]++;\n      }\n    });\n    currentPlayer.points = playerTileCounts[currentPlayer.id] + currentPlayer.score;\n    const hasVictory = currentPlayer.points >= 40;\n\n    // Check if the currentPlayer has any valid moves or attacks\n    const hasValidMoves = hexagons.some(hex => hex.owner === currentPlayer.id && hex.hasUnit && !hex.moved);\n\n    // Check if the currentPlayer has any valid attacks\n    const hasValidAttacks = hexagons.some(hex => hex.owner === currentPlayer.id && hex.hasUnit && !hex.attack && hex.adjacent);\n    if (hasVictory) {\n      return false;\n    } else return hasValidMoves || hasValidAttacks || hasVictory;\n  }\n  // Ends the current player's turn\n  endTurn() {\n    const {\n      currentPlayer,\n      hexagons\n    } = this.state;\n    const playerScore = calculatePlayerScore(currentPlayer, hexagons);\n    const updatedPlayers = updatePlayerScore(this.players, currentPlayer, playerScore);\n\n    // Update this.players (if needed) no longer using\n    // this.players = updatedPlayers;\n\n    if (checkVictoryCondition(currentPlayer, playerScore)) {\n      alert(`${currentPlayer.name} wins with a score of ${currentPlayer.score + playerScore}!`);\n\n      // Handle game reset or victory actions here\n    } else {\n      // ... rest of the function\n    }\n    const currentPlayerIndex = this.players.findIndex(player => player.id === currentPlayer.id);\n    const nextPlayerIndex = findNextPlayerIndex(currentPlayerIndex, this.players);\n    this.setState({\n      selectedUnit: null,\n      selectedUnitPosition: null,\n      highlightedHexagons: [],\n      isModalShownThisTurn: false,\n      currentPlayer: this.players[nextPlayerIndex]\n    });\n\n    // Assuming hexagons is part of your component's state\n    const updatedHexagons = resetMovedUnits(this.state.hexagons);\n\n    // Set the state with the updated hexagons\n    this.setState({\n      hexagons: updatedHexagons\n    });\n  }\n  renderPlayerStats() {\n    const {\n      hexagons,\n      currentPlayer,\n      players,\n      displayMode\n    } = this.state;\n    const playerTileCounts = {};\n\n    // Calculate the tile count for each player\n    hexagons.forEach(hex => {\n      const owner = hex.owner;\n      if (owner !== null) {\n        if (!playerTileCounts[owner]) {\n          playerTileCounts[owner] = 0;\n        }\n        playerTileCounts[owner]++;\n      }\n    });\n    return (\n      /*#__PURE__*/\n      // Render the tile count for each player within a HexGrid layout\n      _jsxDEV(HexGrid, {\n        width: 300,\n        height: 130,\n        viewBox: \"-60 -55 120 120\",\n        children: [/*#__PURE__*/_jsxDEV(Layout, {\n          size: {\n            x: 48,\n            y: 48\n          },\n          flat: false,\n          spacing: 1.1,\n          origin: {\n            x: 0,\n            y: 0\n          },\n          children: this.players.map(player => {\n            let qValue;\n            if (player.id === 0) {\n              qValue = 0; // Position player 0's hexagon in the center\n            } else if (player.id === 1) {\n              qValue = -1; // Position player 1's hexagon to the left\n            } else {\n              qValue = 1; // Position player 2's hexagon to the right\n            }\n\n            const isCurrentPlayer = player.id === currentPlayer.id; // Check if this is the current player\n\n            return /*#__PURE__*/_jsxDEV(Hexagon, {\n              q: qValue,\n              r: 0,\n              s: -qValue,\n              owner: player.id,\n              className: `score ${isCurrentPlayer ? 'active' : ''}` // Apply 'active' class for the current player\n              ,\n              opacity: isCurrentPlayer ? 1.0 : 0.0 // Set opacity based on whether it's the current player\n            }, player.id, false, {\n              fileName: _jsxFileName,\n              lineNumber: 573,\n              columnNumber: 13\n            }, this);\n          })\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 559,\n          columnNumber: 7\n        }, this), \"//this is just so the score text doesn't pulse:\", /*#__PURE__*/_jsxDEV(Layout, {\n          size: {\n            x: 44,\n            y: 44\n          },\n          flat: false,\n          spacing: 1.2,\n          origin: {\n            x: 0,\n            y: 0\n          },\n          children: this.players.map(player => {\n            let qValue;\n            if (player.id === 0) {\n              qValue = 0; // Position player 0's hexagon in the center\n            } else if (player.id === 1) {\n              qValue = -1; // Position player 1's hexagon to the left\n            } else {\n              qValue = 1; // Position player 2's hexagon to the right\n            }\n            // Check if this is the current player\n            const isCurrentPlayer = player.id === currentPlayer.id;\n            return /*#__PURE__*/_jsxDEV(Hexagon, {\n              q: qValue,\n              r: 0,\n              s: -qValue,\n              owner: player.id,\n              className: \"score\" // Apply 'active' class for the current player\n              ,\n              opacity: 1,\n              onClick: () => this.toggleDisplayMode(),\n              children: /*#__PURE__*/_jsxDEV(Text, {\n                className: `score text ${player.id === 0 ? 'player-0-text' : ''}`,\n                style: player.id === 0 ? {\n                  fontSize: '20px',\n                  fontWeight: 'bold'\n                } : {},\n                children: player.id === 0 ? displayMode === 'score' ? 'SCORE' : 'COUNT' : displayMode === 'score' ? `${player.score + playerTileCounts[player.id]}` : `${playerTileCounts[player.id] || 0}`\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 613,\n                columnNumber: 15\n              }, this)\n            }, player.id, false, {\n              fileName: _jsxFileName,\n              lineNumber: 603,\n              columnNumber: 13\n            }, this);\n          })\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 589,\n          columnNumber: 4\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 558,\n        columnNumber: 5\n      }, this)\n    );\n  }\n\n  // Add this function to toggle the display mode\n  toggleDisplayMode() {\n    this.setState(prevState => ({\n      displayMode: prevState.displayMode === 'score' ? 'tileCount' : 'score'\n    }));\n  }\n  render() {\n    const {\n      isModalOpen,\n      isModalShownThisTurn,\n      hexagons,\n      path,\n      highlightedHexagons,\n      selectedUnit,\n      selectedUnitPosition,\n      currentPlayer,\n      selectedHex\n    } = this.state;\n\n    // Check if the current player has any valid moves or attacks\n    const hasValidActions = this.hasValidActions();\n\n    // Dynamically set the button's background color based on the current player's color\n    const buttonStyle = {\n      backgroundColor: currentPlayer.color\n    };\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 656,\n        columnNumber: 9\n      }, this), this.renderPlayerStats(), \" \", /*#__PURE__*/_jsxDEV(\"p\", {\n        children: /*#__PURE__*/_jsxDEV(\"button\", {\n          style: buttonStyle,\n          onClick: () => this.endTurn(),\n          children: \"End Turn?\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 659,\n          columnNumber: 10\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 659,\n        columnNumber: 7\n      }, this), /*#__PURE__*/_jsxDEV(HexGrid, {\n        width: 900,\n        height: 800,\n        viewBox: \"-45 -45 90 90\",\n        children: /*#__PURE__*/_jsxDEV(Layout, {\n          size: {\n            x: 7,\n            y: 7\n          },\n          flat: false,\n          spacing: 1.1,\n          origin: {\n            x: 0,\n            y: 0\n          },\n          children: [hexagons.map((hex, i) => /*#__PURE__*/_jsxDEV(Hexagon, {\n            q: hex.q,\n            r: hex.r,\n            s: hex.s,\n            owner: hex.owner // Set the owner attribute based on the hexagon's owner\n            ,\n            className: highlightedHexagons.includes(hex) ? 'active' : (selectedHex === hex ? 'selected' : '') + (hex.pushed ? hex.pushed : '') // Apply 'pushed' class if hexagon is pushed\n            ,\n            onClick: (e, h) => this.onClick(e, h),\n            children: [hex.hasUnit && /*#__PURE__*/_jsxDEV(ShapeRenderer, {\n              shape: this.players[hex.owner - 1].shape // Use the player's shape based on the owner\n              ,\n              fillOpacity: hex.moved && hex.attack ? '0.5' : '1.0'\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 679,\n              columnNumber: 19\n            }, this), !hex.attack && hex.hasUnit && (!hex.moved || hex.adjacent) && /*#__PURE__*/_jsxDEV(ShapeAnimator, {\n              shape: this.players[hex.owner - 1].shape // Use the player's shape based on the owner\n              ,\n              fillOpacity: hex.moved === true ? '0.5' : '1.0',\n              hex: hex,\n              currentPlayer: currentPlayer\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 686,\n              columnNumber: 6\n            }, this), hex.count && !hex.pushed && hex.owner !== currentPlayer && /*#__PURE__*/_jsxDEV(PointRenderer, {\n              hex: hex,\n              currentPlayer: currentPlayer\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 696,\n              columnNumber: 19\n            }, this)]\n          }, i, true, {\n            fileName: _jsxFileName,\n            lineNumber: 664,\n            columnNumber: 15\n          }, this)), /*#__PURE__*/_jsxDEV(Path, {\n            start: path.start,\n            end: path.end\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 707,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 662,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 661,\n        columnNumber: 9\n      }, this), selectedUnit && /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Selected Unit: \", HexUtils.getID(selectedUnitPosition)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 711,\n        columnNumber: 11\n      }, this), selectedHex && /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Selected Hex: \", HexUtils.getID(selectedHex)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 714,\n        columnNumber: 11\n      }, this), isModalShownThisTurn || hasValidActions ? true : /*#__PURE__*/_jsxDEV(ConfirmationModal, {\n        hexagons: this.hexagons,\n        players: this.players,\n        currentPlayer: currentPlayer,\n        isOpen: true // Always open the modal when there are no valid actions\n        ,\n        onReset: () => this.handleReset(),\n        onCancel: () => this.handleCancel(),\n        onConfirm: () => this.handleConfirm()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 718,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 655,\n      columnNumber: 7\n    }, this);\n  }\n}\nclass PointRenderer extends React.Component {\n  render() {\n    const {\n      hex,\n      shape,\n      fill,\n      fillOpacity,\n      className,\n      currentPlayer\n    } = this.props;\n    return /*#__PURE__*/_jsxDEV(\"text\", {\n      className: \"push-animation\",\n      x: \"-0.5em\",\n      y: \"-0.5em\",\n      children: [\"+\", hex.count]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 744,\n      columnNumber: 7\n    }, this);\n    return null;\n  }\n}\nclass ShapeRenderer extends React.Component {\n  render() {\n    const {\n      shape,\n      fill,\n      fillOpacity,\n      className\n    } = this.props;\n    if (shape === \"circle\") {\n      return /*#__PURE__*/_jsxDEV(\"circle\", {\n        cx: \"0\",\n        cy: \"0\",\n        r: \"1\",\n        fill: fill,\n        fillOpacity: fillOpacity,\n        className: className,\n        children: \";\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 770,\n        columnNumber: 16\n      }, this);\n    }\n    return null;\n  }\n}\nclass ShapeAnimator extends React.Component {\n  shouldAnimate() {\n    const {\n      hex,\n      currentPlayer\n    } = this.props;\n    return hex.owner === currentPlayer.id;\n  }\n  render() {\n    const {\n      shape,\n      fill,\n      fillOpacity,\n      className\n    } = this.props;\n    if (shape === \"circle\") {\n      return /*#__PURE__*/_jsxDEV(\"circle\", {\n        cx: \"0\",\n        cy: \"0\",\n        r: \"1\",\n        fill: fill,\n        fillOpacity: fillOpacity,\n        className: className,\n        children: [\";\", this.shouldAnimate() && /*#__PURE__*/_jsxDEV(_Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"animate\", {\n            attributeName: \"r\",\n            from: \"1\",\n            to: \"2\",\n            dur: \"1.5s\",\n            begin: \"0s\",\n            repeatCount: \"indefinite\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 792,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"animate\", {\n            attributeName: \"opacity\",\n            from: \"1\",\n            to: \"0\",\n            dur: \"1.5s\",\n            begin: \"0s\",\n            repeatCount: \"indefinite\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 793,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 789,\n        columnNumber: 16\n      }, this);\n    }\n    return null;\n  }\n}\n\n// Reset Animations on Click - needs some work - does this even do anything?\ndocument.addEventListener('click', function () {\n  const animatedElements = document.querySelectorAll('.hexagon');\n\n  // Add a class to pause animations\n  animatedElements.forEach(function (element) {\n    element.style.animation = 'none'; // Set animation to an empty string\n  });\n\n  // After 10 ms, remove the class to resume animations\n  setTimeout(function () {\n    animatedElements.forEach(function (element) {\n      element.style.animation = ''; // Set animation to an empty string\n    });\n  }, 10);\n});\nexport default App;","map":{"version":3,"names":["React","Component","GridGenerator","HexGrid","Layout","Path","Text","Hexagon","HexUtils","ConfirmationModal","calculatePlayerScore","updatePlayerScore","checkVictoryCondition","findNextPlayerIndex","resetMovedUnits","checkSurroundedHexagons","jsxDEV","_jsxDEV","Fragment","_Fragment","App","constructor","props","handleConfirm","endTurn","setState","isModalOpen","handleCancel","isModalShownThisTurn","handleReset","window","location","reload","players","id","name","color","shape","points","score","hexagons","hexagon","map","hex","owner","r","hasUnit","moved","attack","pushed","adjacent","count","state","path","start","end","highlightedHexagons","currentPlayer","selectedUnit","selectedUnitPosition","selectedHex","displayMode","onClick","event","source","targetHex","clickedHex","find","equals","isUnitHex","isHighlightedHex","moveUnit","filter","distance","highlightAttackableTiles","adjacentEnemyHexagons","length","hasPushableUnit","direction","q","s","Math","abs","behindHex","behindHexagon","pushUnit","undefined","some","highlightedHex","unitHex","targetIndex","findIndex","updatedHexagons","calculateDirection","sourceHex","qDiff","rDiff","sourceIndex","newTargetHex","newTargetIndex","newTargetOutsideBoard","setTimeout","alert","hasValidActions","playerTileCounts","forEach","hasVictory","hasValidMoves","hasValidAttacks","playerScore","updatedPlayers","currentPlayerIndex","player","nextPlayerIndex","renderPlayerStats","width","height","viewBox","children","size","x","y","flat","spacing","origin","qValue","isCurrentPlayer","className","opacity","fileName","_jsxFileName","lineNumber","columnNumber","toggleDisplayMode","style","fontSize","fontWeight","prevState","render","buttonStyle","backgroundColor","i","includes","e","h","ShapeRenderer","fillOpacity","ShapeAnimator","PointRenderer","getID","isOpen","onReset","onCancel","onConfirm","fill","cx","cy","shouldAnimate","attributeName","from","to","dur","begin","repeatCount","document","addEventListener","animatedElements","querySelectorAll","element","animation"],"sources":["C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/src/HexagonalGrid.js"],"sourcesContent":["/* src/HexagonalGrid.js */\r\n\r\nimport React, { Component } from 'react';\r\nimport { GridGenerator, HexGrid, Layout, Path, Text, Hexagon, HexUtils } from 'react-hexgrid';\r\nimport './App.css';\r\nimport ConfirmationModal from './ConfirmationModal'; // Import the ConfirmationModal component\r\nimport { calculatePlayerScore, updatePlayerScore, checkVictoryCondition, findNextPlayerIndex, resetMovedUnits, checkSurroundedHexagons} from './GameLogic';\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // Define player representations\r\nthis.players = [\r\n  { id: 0, name: \"Player 0\", color: \"grey\", shape: \"circle\", points: 0, score: 0 },\r\n  { id: 1, name: \"Player 1\", color: \"blue\", shape: \"circle\", points: 0, score: 0 },\r\n  { id: 2, name: \"Player 2\", color: \"red\", shape: \"circle\",  points: 0,  score: 0 },\r\n];\r\n    \r\n    // Create hexagons and assign them to players\r\n    const hexagons = GridGenerator.hexagon(3).map(hex => ({\r\n      ...hex,\r\n      //owner: Math.random() < 0.5 ? 1 : 2, // Assign to player 1 or 2 - MODE 1 RANDOM\r\n\t  owner: hex.r === -3 ? 1 : hex.r === 3 ? 2 : 0, // Assign ownership based on row number - MAIN MODE\r\n      //hasUnit: Math.random() < 0.2, // Adjust the probability as needed - MODE 1 RANDOM\r\n\t  hasUnit: hex.r === -3 ? true : hex.r === 3 ? true : false, // Assign ownership based on row number - MAIN MODE\r\n      moved: false,\r\n      attack: false,\r\n\t  pushed: null,\r\n\t  adjacent: null,\r\n\t  count: 0,\r\n    }));\r\n\r\n    this.state = {\r\n      hexagons,\r\n      path: { start: null, end: null },\r\n      highlightedHexagons: [],\r\n      currentPlayer: this.players[1], // Start with the first player\r\n      selectedUnit: null,\r\n      selectedUnitPosition: null,\r\n      selectedHex: null,\r\n\t  isModalOpen: false,\r\n      isModalShownThisTurn: false,  // Track if the modal was shown this turn\r\n\t  displayMode: 'score', //default display mode\r\n    };\r\n  }\r\n\r\n\r\n\r\n  onClick(event, source) {\r\n    const { path, hexagons, selectedUnit, currentPlayer, selectedHex} = this.state;\r\n    const targetHex = source.state.hex;\r\n\t\r\n\t\r\n    // Clear previous path or selection\r\n    if (path.start == null) {\r\n      path.start = source.state.hex;\r\n    } else {\r\n      path.start = null;\r\n      path.end = null;\r\n    }\r\n\t\t\t\t\r\n\t\t\r\n    const clickedHex = hexagons.find(hex => HexUtils.equals(hex, targetHex));\r\n    const isUnitHex = clickedHex && clickedHex.hasUnit;\r\n\tthis.setState({ selectedHex: null});\r\n\r\n    // Movement Logic\r\n    if (isUnitHex && clickedHex.owner === currentPlayer.id) {\r\n      // If the clicked hexagon has a unit and the unit belongs to the current player\r\n\t  this.setState({ selectedHex: clickedHex });\r\n      if (!clickedHex.moved) {\r\n        this.setState({\r\n          selectedUnit: clickedHex,\r\n          selectedUnitPosition: targetHex,\r\n        });\r\n      } else {\r\n        this.setState({\r\n          selectedUnit: clickedHex,\r\n          selectedUnitPosition: targetHex,\r\n        });\r\n      }\r\n    } else if (selectedUnit && this.isHighlightedHex(targetHex) && !clickedHex.hasUnit ){\r\n      // If a unit is selected and a highlighted hexagon is clicked, move the unit or attack\r\n      this.moveUnit(selectedUnit, targetHex);\r\n\t  this.setState({ selectedHex: clickedHex});\r\n    } else if (this.isHighlightedHex(targetHex)) { \r\n      this.moveUnit(selectedHex, clickedHex);\r\n    }\r\n\r\n    // Highlight Controller\r\n    if (!clickedHex.moved && clickedHex.owner === currentPlayer.id) {\r\n      // Calculate highlighted hexagons that are exactly 2 hexagon distances away only if it's a unit hex\r\n      const highlightedHexagons = isUnitHex\r\n        ? hexagons.filter(hex => {\r\n          const distance = HexUtils.distance(targetHex, hex);\r\n          return distance <= 2 && !hex.hasUnit;\r\n        })\r\n        : [];\r\n      this.setState({ path, highlightedHexagons });\r\n    } else {\r\n      this.setState({ path, highlightedHexagons: [] });\r\n    }\r\n\r\n    if (clickedHex.moved && !clickedHex.attack && clickedHex.hasUnit && clickedHex.adjacent) {\r\n      // Calculate highlighted hexagons that are exactly 1 hexagon distance away only if it's a unit hex\r\n      this.highlightAttackableTiles(targetHex, currentPlayer, hexagons);\r\n    }\r\n\t\r\n// OnClick Adjacent Logic: Highlight tiles for movement and attack\r\nif (isUnitHex && !clickedHex.moved && clickedHex.owner === currentPlayer.id) {\r\n  const adjacentEnemyHexagons = hexagons.filter(hex => {\r\n    const distance = HexUtils.distance(targetHex, hex);\r\n    return distance === 1 && hex.hasUnit && hex.owner !== currentPlayer.id;\r\n  });\r\n\r\n  if (adjacentEnemyHexagons.length > 0) {\r\n    const highlightedHexagons = hexagons.filter(hex => {\r\n      const distance = HexUtils.distance(targetHex, hex);\r\n      return distance === 1 && (hex.hasUnit && hex.owner) !== currentPlayer.id;\r\n    });\r\n\t\r\n\r\n\t\r\n\t  // Check if there is a unit behind the target hexagon that can be pushed\r\n  const hasPushableUnit = highlightedHexagons.filter(hex => {\r\n    const direction = {\r\n      q: hex.q - targetHex.q,\r\n      r: hex.r - targetHex.r,\r\n      s: hex.s - targetHex.s\r\n    };\r\n\t\r\n\t\r\n\t\r\n\t    // Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\r\n    if (Math.abs(direction.q) <= 1 && Math.abs(direction.r) <= 1 && Math.abs(direction.s) <= 1) {\r\n      const behindHex = {\r\n        q: hex.q + direction.q,\r\n        r: hex.r + direction.r,\r\n        s: hex.s + direction.s\r\n      };\r\n  \r\n      // Find the hexagon at the behindHex position\r\n      const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\r\n\t  \r\n\t  const pushUnit = hexagons.find(hex => HexUtils.equals(hex, direction));\r\n\t  \r\n\t\r\n\t  \r\n\t  if(behindHexagon == undefined){\r\n\t\t \r\n\t\t  return hex;\r\n\t  }\r\n\t   else if(!behindHexagon.hasUnit){  \r\n\t   \r\n\t\treturn hex;\r\n\t  } else if(!hex.hasUnit && !behindHex.hasUnit){\r\n\t\t\r\n\t\treturn hex;\r\n\t}\r\n    }\r\n\t\r\n\t});\r\n\r\n    this.setState({ highlightedHexagons : hasPushableUnit });\t\r\n\t\r\n\t\r\n  } else {\r\n    const highlightedHexagons = hexagons.filter(hex => {\r\n      const distance = HexUtils.distance(targetHex, hex);\r\n      return distance <= 2 && !hex.hasUnit;\r\n    });\r\n\r\n    this.setState({ path, highlightedHexagons });\r\n  }\r\n}\t\r\n  } //on click ends\r\n\r\n\r\n  \r\n  // Highlights hexagons that can be attacked\r\n  highlightAttackableTiles(targetHex, currentPlayer, hexagons) {\r\n    const highlightedHexagons = hexagons.filter(hex => {\r\n      const distance = HexUtils.distance(targetHex, hex);\r\n      return distance === 1 && hex.hasUnit && hex.owner !== currentPlayer.id;\r\n    });\r\n\r\n\t\r\n\t  // Check if there is a unit behind the target hexagon that can be pushed\r\n  const hasPushableUnit = highlightedHexagons.filter(hex => {\r\n    const direction = {\r\n      q: hex.q - targetHex.q,\r\n      r: hex.r - targetHex.r,\r\n      s: hex.s - targetHex.s\r\n    };\r\n\t    // Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\r\n    if (Math.abs(direction.q) <= 1 && Math.abs(direction.r) <= 1 && Math.abs(direction.s) <= 1) {\r\n      const behindHex = {\r\n        q: hex.q + direction.q,\r\n        r: hex.r + direction.r,\r\n        s: hex.s + direction.s\r\n      };\r\n  \r\n      // Find the hexagon at the behindHex position\r\n      const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\r\n\t  \r\n\t  const pushUnit = hexagons.find(hex => HexUtils.equals(hex, direction));\r\n\t  \r\n\t  if(behindHexagon == undefined){\r\n\t\t  return pushUnit;\r\n\t  }\r\n\t   else if(!behindHexagon.hasUnit){  \r\n\t\treturn pushUnit;\r\n\t  } \r\n    }\t\t\r\n\t});\r\n\r\n    this.setState({ highlightedHexagons : hasPushableUnit });\t\r\n\t\r\n  }\r\n  \r\n\r\n  // Checks if a hexagon is highlighted\r\n  isHighlightedHex(hex) {\r\n    const { highlightedHexagons } = this.state;\r\n    return highlightedHexagons.some(highlightedHex => HexUtils.equals(hex, highlightedHex));\r\n  }\r\n  \r\n  // Movement and Attack Mechanics\r\n  moveUnit(unitHex, targetHex) {\r\n    const { hexagons, currentPlayer, selectedUnit, selectedHex } = this.state;\r\n\t\r\n    // If the selected unit has not moved yet, move it\r\n    if (!unitHex.moved && !targetHex.hasUnit ) {\r\n      unitHex.hasUnit = false;\r\n      \r\n      // Update the target hexagon to have a unit and mark it as moved\r\n      const targetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, targetHex));\r\n      if (targetIndex !== -1) {\r\n        hexagons[targetIndex].hasUnit = true;\r\n        hexagons[targetIndex].moved = true;\r\n        hexagons[targetIndex].attack = false;\r\n        hexagons[targetIndex].owner = currentPlayer.id; // Update the owner to the current player's id\r\n      }\r\n    }  else{ //Otherwise we can only push the unit\r\n\t\t\r\n      this.pushUnit(unitHex, targetHex, hexagons, currentPlayer);\r\n\t  \r\n\r\n\t}\r\n    this.setState({\r\n      selectedUnit: null,\r\n      selectedUnitPosition: null,\r\n      hexagons: [...hexagons],\r\n      highlightedHexagons: [],\r\n    });\r\n\t\r\n\tconst updatedHexagons = checkSurroundedHexagons(this.state.hexagons);\t \r\n  }\r\n \r\n// Calculate the direction for nudge animation\r\ncalculateDirection(sourceHex, targetHex) {\r\n  const qDiff = targetHex.q - sourceHex.q;\r\n  const rDiff = targetHex.r - sourceHex.r;\r\n\r\n  if (qDiff > 0 && rDiff === 0) {\r\n    return 'East';\r\n  } else if (qDiff < 0 && rDiff === 0) {\r\n    return 'West';\r\n  } else if (qDiff === 0 && rDiff > 0) {\r\n    return 'SE';\r\n  } else if (qDiff === 0 && rDiff < 0) {\r\n    return 'NW';\r\n  } else if (qDiff > 0 && rDiff < 0) {\r\n    return 'NE';\r\n  } else if (qDiff < 0 && rDiff > 0) {\r\n    return 'SW';\r\n  }\r\n\r\n  // Handle other cases if needed\r\n\r\n  return 'unknown';\r\n}\r\n\r\n \r\n// PUSH LOGIC\r\npushUnit(sourceHex, targetHex, hexagons, currentPlayer) {\r\n  const sourceIndex = hexagons.findIndex(hex => HexUtils.equals(hex, sourceHex));\r\n  const targetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, targetHex));\r\n  \r\n\r\n  if (sourceIndex !== -1 && targetIndex !== -1) {\r\n    // Check if the target hex is empty\r\n    if (hexagons[targetIndex].hasUnit) {\r\n      // Calculate the direction of the push\r\n      const direction = {\r\n        q: targetHex.q - sourceHex.q,\r\n        r: targetHex.r - sourceHex.r,\r\n        s: targetHex.s - sourceHex.s\r\n      };\r\n\r\n      // Calculate the new position for the target unit\r\n      const newTargetHex = {\r\n        q: targetHex.q + direction.q,\r\n        r: targetHex.r + direction.r,\r\n        s: targetHex.s + direction.s\r\n      };\r\n\r\n\t\tconst newTargetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, newTargetHex));\r\n\t  \r\n\t      // Check if the target hex is outside the game board\r\n\t\tconst newTargetOutsideBoard = newTargetHex.q < -3 || newTargetHex.q > 3 || newTargetHex.r < -3 || newTargetHex.r > 3 || newTargetHex.s < -3 || newTargetHex.s > 3;\r\n  \r\n\r\n\r\n      if (newTargetIndex !== -1 && !hexagons[newTargetIndex].hasUnit) {\r\n        // Move the target unit to the new position\r\n        hexagons[newTargetIndex].hasUnit = true;\r\n        hexagons[newTargetIndex].moved = false;\r\n        hexagons[newTargetIndex].attack = true; // or whatever the appropriate attack status is\r\n        hexagons[newTargetIndex].owner = hexagons[targetIndex].owner;\r\n\t\thexagons[newTargetIndex].count = hexagons[targetIndex].count + 1;\r\n\t\tcurrentPlayer.score = currentPlayer.score + hexagons[targetIndex].count + 1;\r\n\t\r\n\r\n        // Clear the target hex\r\n        hexagons[targetIndex].hasUnit = false;\r\n        hexagons[targetIndex].moved = true;\r\n        hexagons[targetIndex].attack = false;\r\n\t\thexagons[targetIndex].count = null;\r\n\r\n        // Update the owner to the current player's id\r\n        hexagons[targetIndex].owner = 0;\r\n\t\t\r\n\t\t//Update source unit so they can no longer push or move if push was successful\r\n\t\tsourceHex.attack = true;\r\n\t\tsourceHex.moved = true;\r\n\t\r\n\r\n    // Clear the highlighted hexagons and selectedHex\r\n    this.setState({\r\n      highlightedHexagons: [],\r\n      selectedHex: null  // Clear the selectedHex when a push occurs\r\n    });\r\n\t\r\n  // Calculate the direction for nudge animation target\r\nhexagons[newTargetIndex].pushed = this.calculateDirection(sourceHex, targetHex);\r\n\r\n// Calculate the direction for the nudge animation source\r\nsourceHex.pushed = 's' + this.calculateDirection(sourceHex, targetHex);\r\n \r\n\r\n// Reset the pushed class after 500 milliseconds (adjust the duration as needed)\r\nsetTimeout(() => {\r\n\t\r\n\thexagons[newTargetIndex].pushed = null;\r\n\tsourceHex.pushed = null;\r\n\tthis.setState({ hexagons: [...hexagons] }); // Update the state to re-render with the updated hexagons\r\n}, 500); // Adjust the duration (in milliseconds) as needed\r\n\t\t\t\r\n        // Clear the highlighted hexagons\r\n        this.setState({\r\n          selectedUnit: null,\r\n          selectedUnitPosition: null,\r\n          hexagons: [...hexagons],\r\n          highlightedHexagons: [],\r\n        });\r\n\t\t\r\n\t\t\r\n      } else if (newTargetOutsideBoard) {\r\n\t\t//alert('Cannot push. Target position is outside board.');\r\n\t\t\r\n\t\t//removal + animation here\r\n\r\n\t\t\r\n\t\t//Update source unit so they can no longer push or move if push was successful\r\n\t\tsourceHex.attack = true;\r\n\t\tsourceHex.moved = true;\r\n\r\n  // Calculate the direction for nudge animation target\r\nhexagons[targetIndex].pushed = 'f' + this.calculateDirection(sourceHex, targetHex);\t\t\r\n\t\t// Calculate the direction for the nudge animation source\r\nsourceHex.pushed = 's' + this.calculateDirection(sourceHex, targetHex);\r\n\t\t\r\n\t\t// Reset the pushed class after 500 milliseconds (adjust the duration as needed)\r\nsetTimeout(() => {\r\n\t\r\n\t\r\n\t\r\n\t\t        // Clear the target hex\r\n        hexagons[targetIndex].hasUnit = false;\r\n        hexagons[targetIndex].moved = true;\r\n        hexagons[targetIndex].attack = false;\r\n\t\r\n\thexagons[targetIndex].pushed = null;\r\n\tsourceHex.pushed = null;\r\n\t\r\n\tif(!hexagons[targetIndex].count){\r\n\t\thexagons[targetIndex].count = 2;\r\n\t} else hexagons[targetIndex].count = (hexagons[targetIndex].count)*2;\r\n\t\r\n\r\n\tcurrentPlayer.score = currentPlayer.score + hexagons[targetIndex].count;\r\n\r\n\t\r\n\t// Update the owner to the current player's id\r\n        hexagons[targetIndex].owner = 0;\r\n\tconst updatedHexagons = checkSurroundedHexagons(this.state.hexagons); // included here because it is not working under the move function when pushed off the edge\r\n\t\r\n\tthis.setState({ hexagons: [...hexagons] }); // Update the state to re-render with the updated hexagons\r\n}, 1000); // Adjust the duration (in milliseconds) as needed\r\n\t\t\t\r\n        // Clear the highlighted hexagons\r\n        this.setState({\r\n          selectedUnit: null,\r\n          selectedUnitPosition: null,\r\n          hexagons: [...hexagons],\r\n          highlightedHexagons: [],\r\n        });\r\n\t\t\t\r\n      } else {\r\n\t\talert('Cannot push. Target position is occupied');  \r\n\t  }\r\n    } \r\n  } \r\n}\r\n\r\n   // Function to check if the current player has any valid moves or attacks\r\nhasValidActions() {\r\n    const { hexagons, players, currentPlayer} = this.state;\r\n\t\r\n\t  const playerTileCounts = {};\r\n\r\n  // Calculate the tile count for each player\r\n  hexagons.forEach(hex => {\r\n    const owner = hex.owner;\r\n    if (owner !== null) {\r\n      if (!playerTileCounts[owner]) {\r\n        playerTileCounts[owner] = 0;\r\n      }\r\n      playerTileCounts[owner]++;\r\n    }\r\n  });\r\n\r\n currentPlayer.points = playerTileCounts[currentPlayer.id] + currentPlayer.score;\r\n\t\r\n\t\r\n\tconst hasVictory = currentPlayer.points >= 40;\r\n\r\n    // Check if the currentPlayer has any valid moves or attacks\r\n    const hasValidMoves = hexagons.some(hex => hex.owner === currentPlayer.id && hex.hasUnit && !hex.moved);\r\n\r\n    // Check if the currentPlayer has any valid attacks\r\n    const hasValidAttacks = hexagons.some(\r\n      hex =>\r\n        hex.owner === currentPlayer.id && hex.hasUnit &&\r\n        !hex.attack && hex.adjacent\r\n        \r\n    );\r\n\t\r\n\r\n\t\r\n\t\r\n      \r\n\r\n\tif(hasVictory) {\r\n\t\t\r\n\t\t\r\n\t\treturn false;\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t}else \r\n\t\t\r\n return hasValidMoves || hasValidAttacks || hasVictory;\r\n\r\n  }\r\n\r\n  handleConfirm = () => {\r\n    this.endTurn();\r\n    this.setState({ isModalOpen: false});\r\n  };\r\n\r\n  handleCancel = () => {\r\n    this.setState({ isModalOpen: false, isModalShownThisTurn: true });\r\n  };  \r\n  \r\n  \r\nhandleReset = () => {\r\n\t\r\nwindow.location.reload();\r\n\r\n  };\r\n\r\n  \r\n  \r\n  // Ends the current player's turn\r\nendTurn() {\r\n  const { currentPlayer, hexagons } = this.state;\r\n\r\n  const playerScore = calculatePlayerScore(currentPlayer, hexagons);\r\n  const updatedPlayers = updatePlayerScore(this.players, currentPlayer, playerScore);\r\n\r\n  // Update this.players (if needed) no longer using\r\n // this.players = updatedPlayers;\r\n\r\n  if (checkVictoryCondition(currentPlayer, playerScore)) { \r\n\t  \r\n\t  \r\n    alert(`${currentPlayer.name} wins with a score of ${currentPlayer.score + playerScore}!`);\r\n\t\r\n\t\r\n    // Handle game reset or victory actions here\r\n  } else {\r\n    // ... rest of the function\r\n  }\r\n\r\n  const currentPlayerIndex = this.players.findIndex(player => player.id === currentPlayer.id);\r\n  const nextPlayerIndex = findNextPlayerIndex(currentPlayerIndex, this.players);\r\n\r\n  this.setState({\r\n    selectedUnit: null,\r\n    selectedUnitPosition: null,\r\n    highlightedHexagons: [],\r\n    isModalShownThisTurn: false,\r\n    currentPlayer: this.players[nextPlayerIndex]\r\n  });\r\n  \r\n// Assuming hexagons is part of your component's state\r\nconst updatedHexagons = resetMovedUnits(this.state.hexagons);\r\n\r\n// Set the state with the updated hexagons\r\nthis.setState({ hexagons: updatedHexagons });\r\n}\r\n\r\n  \r\n\r\n  \r\nrenderPlayerStats() {\r\n  const { hexagons, currentPlayer, players, displayMode } = this.state;\r\n  const playerTileCounts = {};\r\n\r\n  // Calculate the tile count for each player\r\n  hexagons.forEach(hex => {\r\n    const owner = hex.owner;\r\n    if (owner !== null) {\r\n      if (!playerTileCounts[owner]) {\r\n        playerTileCounts[owner] = 0;\r\n      }\r\n      playerTileCounts[owner]++;\r\n    }\r\n  });\r\n\r\n \r\n\r\n  return (  // Render the tile count for each player within a HexGrid layout\r\n  \r\n    <HexGrid width={300} height={130} viewBox=\"-60 -55 120 120\">\r\n      <Layout size={{ x: 48, y: 48 }} flat={false} spacing={1.1} origin={{ x: 0, y: 0 }}>\r\n        {this.players.map(player => {\r\n          let qValue;\r\n          if (player.id === 0) {\r\n            qValue = 0; // Position player 0's hexagon in the center\r\n          } else if (player.id === 1) {\r\n            qValue = -1; // Position player 1's hexagon to the left\r\n          } else {\r\n            qValue = 1; // Position player 2's hexagon to the right\r\n          }\r\n\r\n          const isCurrentPlayer = player.id === currentPlayer.id;  // Check if this is the current player\r\n\t\t  \r\n          return (\r\n            <Hexagon\r\n              key={player.id}\r\n              q={qValue}\r\n              r={0}\r\n              s={-qValue}\r\n              owner={player.id}\r\n              className={`score ${isCurrentPlayer ? 'active' : ''}`}  // Apply 'active' class for the current player\r\n\t\t\t  opacity={isCurrentPlayer ? 1.0 : 0.0}  // Set opacity based on whether it's the current player\r\n            >\t\t\r\n            </Hexagon>\t\r\n          );\r\n        })}\r\n\t\t\r\n      </Layout>\r\n\t  \r\n\t  //this is just so the score text doesn't pulse:\r\n\t  <Layout size={{ x: 44, y: 44 }} flat={false} spacing={1.2} origin={{ x: 0, y: 0 }}>\r\n\t  {this.players.map(player => {\r\n          let qValue;\r\n          if (player.id === 0) {\r\n            qValue = 0; // Position player 0's hexagon in the center\r\n          } else if (player.id === 1) {\r\n            qValue = -1; // Position player 1's hexagon to the left\r\n          } else {\r\n            qValue = 1; // Position player 2's hexagon to the right\r\n          }\r\n\t\t            // Check if this is the current player\r\n          const isCurrentPlayer = player.id === currentPlayer.id;\r\n\t\t  \r\n          return (\r\n            <Hexagon\r\n              key={player.id}\r\n              q={qValue}\r\n              r={0}\r\n              s={-qValue}\r\n              owner={player.id}\r\n              className={\"score\"}  // Apply 'active' class for the current player\r\n\t\t\t  opacity={1}\r\n\t\t\t  onClick={() => this.toggleDisplayMode()}\r\n            >\r\n              <Text className={`score text ${player.id === 0 ? 'player-0-text' : ''}`} style={player.id === 0 ? { fontSize: '20px', fontWeight: 'bold' } : {}}>\r\n              {/*  {displayMode === 'score' ? `${playerTileCounts[player.id] || 0}` : `${player.score}`} just displays scores */}\r\n\t\t\t\t\r\n\t\t\t\t{player.id === 0 ? (displayMode === 'score' ? 'SCORE' : 'COUNT' ) : (displayMode === 'score' ?  `${player.score + playerTileCounts[player.id] }` :`${playerTileCounts[player.id] || 0}`)}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\r\n              </Text>\r\n\t\t\t  \r\n            </Hexagon>\r\n          );\r\n        })}\r\n\t  </Layout>\r\n    </HexGrid>\r\n\t\r\n\t\t\r\n\t\r\n  );\r\n}\r\n\r\n// Add this function to toggle the display mode\r\ntoggleDisplayMode() {\r\n  this.setState(prevState => ({\r\n    displayMode: prevState.displayMode === 'score' ? 'tileCount' : 'score',\r\n  }));\r\n}\r\n\r\n\r\n\r\n  render() {\r\n    const { isModalOpen, isModalShownThisTurn, hexagons, path, highlightedHexagons, selectedUnit, selectedUnitPosition, currentPlayer, selectedHex } = this.state;\r\n\t\r\n\t// Check if the current player has any valid moves or attacks\r\n    const hasValidActions = this.hasValidActions();\r\n\t\r\n\t\r\n\t // Dynamically set the button's background color based on the current player's color\r\n  const buttonStyle = {\r\n    backgroundColor: currentPlayer.color,\r\n  };\r\n\r\n\t\r\n    return (\r\n      <div className=\"App\">\r\n        <h2></h2>\r\n\t\t{this.renderPlayerStats()} {/* Render player tile counts */}  \r\n        {/* Update the button style to use the dynamic style */}\r\n      <p><button style={buttonStyle} onClick={() => this.endTurn()}>End Turn?</button></p>\r\n\t\t\r\n        <HexGrid width={900} height={800} viewBox=\"-45 -45 90 90\" >\r\n          <Layout size={{ x: 7, y: 7 }} flat={false} spacing={1.1} origin={{ x: 0, y: 0 }}>\r\n            {hexagons.map((hex, i) => (\r\n              <Hexagon\r\n                key={i}\r\n                q={hex.q}\r\n                r={hex.r}\r\n                s={hex.s}\r\n                owner={hex.owner} // Set the owner attribute based on the hexagon's owner\r\n                className={highlightedHexagons.includes(hex) ? 'active' : (selectedHex === hex ? 'selected' : '') + (hex.pushed ? hex.pushed : '')}  // Apply 'pushed' class if hexagon is pushed\r\n                onClick={(e, h) => this.onClick(e, h)}\r\n              >\r\n              {/*  <Text>{HexUtils.getID(hex)}</Text>  */}\r\n\t\t\t  {/*<Path start={path.start} end={selectedHex} /> //work on this to draw arrows*/}\r\n\t\t\t  \r\n\t\t\t  {/* ANIMATIONS HERE - still need to move CSS animations to function better */}\r\n\t\t\t  \r\n                {hex.hasUnit && (\r\n                  <ShapeRenderer\r\n                    shape={this.players[hex.owner - 1].shape} // Use the player's shape based on the owner\r\n\t\t\t\t\tfillOpacity={hex.moved && hex.attack  ? '0.5' : '1.0'}\t\t\t\t\t\t\r\n                  />\r\n                )}\r\n\t\t\t\t\r\n\t\t\t\t{!hex.attack && hex.hasUnit && (!hex.moved || hex.adjacent) && (\r\n\t\t\t\t <ShapeAnimator\r\n                    shape={this.players[hex.owner - 1].shape} // Use the player's shape based on the owner\r\n\t\t\t\t\tfillOpacity={hex.moved === true ? '0.5' : '1.0'}\t\r\n\t\t\t\t\thex={hex}\r\n\t\t\t\t\tcurrentPlayer={currentPlayer}\r\n                  />\r\n\t\t\t\t)} \r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t{hex.count && !hex.pushed && (hex.owner !== currentPlayer) && (\r\n                  <PointRenderer\r\n                    \thex={hex}\r\n\t\t\t\t\t\tcurrentPlayer={currentPlayer}\t\r\n                  />\r\n                )}\t\r\n\t\t\r\n\t\t\t {/* ANIMATIONS HERE - still need to move CSS animations to function better */}\r\n\t\t\t\r\n\t\t\t\r\n             </Hexagon>\r\n            ))}\r\n            <Path start={path.start} end={path.end} />\r\n          </Layout>\r\n        </HexGrid>\r\n        {selectedUnit && (\r\n          <p>Selected Unit: {HexUtils.getID(selectedUnitPosition)}</p>\r\n        )}\r\n        {selectedHex && (\r\n          <p>Selected Hex: {HexUtils.getID(selectedHex)}</p>\r\n        )}\r\n {/* Conditionally show the ConfirmationModal */}\r\n        { isModalShownThisTurn || hasValidActions ? true : (\r\n          <ConfirmationModal\r\n\t\t    hexagons={this.hexagons}\r\n\t\t    players={this.players}\r\n\t\t    currentPlayer = {currentPlayer}\r\n            isOpen={true} // Always open the modal when there are no valid actions\r\n\t\t\tonReset={() => this.handleReset()}\r\n            onCancel={() => this.handleCancel()}\r\n            onConfirm={() => this.handleConfirm()}\r\n          />\r\n        )}\r\n\r\n     </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nclass PointRenderer extends React.Component {\r\n\r\n  \r\n  render() {\r\n    const { hex, shape, fill, fillOpacity, className, currentPlayer } = this.props;\r\n\t\r\n    \r\n      return (      \r\n\t\t\r\n      <text\r\n        className=\"push-animation\"\r\n\t\t \r\n\t\t x=\"-0.5em\"\r\n\t\t y=\"-0.5em\" \r\n\t\t  \r\n      >\r\n        \r\n\t\t\r\n\r\n\t  +{hex.count}\r\n\t\t\r\n\t\t\r\n\t\t\r\n      </text>\r\n\t  );  \r\n    \r\n    return null;\r\n  }\r\n}\r\n\r\n\r\nclass ShapeRenderer extends React.Component {\r\n  render() {\r\n    const { shape, fill, fillOpacity, className } = this.props;\r\n    if (shape === \"circle\") {\r\n      return ( <circle cx=\"0\" cy=\"0\" r=\"1\" fill={fill} fillOpacity={fillOpacity}  className={className} >;\r\n\t  </circle>\r\n\t  );  \r\n    } \r\n    return null;\r\n  }\r\n}\r\n\r\n\r\n\r\nclass ShapeAnimator extends React.Component {\r\n  shouldAnimate() {\r\n    const { hex, currentPlayer } = this.props;\r\n    return hex.owner === currentPlayer.id;\r\n  }\t\r\n\t\r\n  render() {\r\n    const { shape, fill, fillOpacity, className } = this.props;\r\n    if (shape === \"circle\") {\r\n      return ( <circle cx=\"0\" cy=\"0\" r=\"1\" fill={fill} fillOpacity={fillOpacity}  className={className}>;\r\n          {this.shouldAnimate() && (\r\n            <>\r\n              <animate attributeName=\"r\" from=\"1\" to=\"2\" dur=\"1.5s\" begin=\"0s\" repeatCount=\"indefinite\" />\r\n              <animate attributeName=\"opacity\" from=\"1\" to=\"0\" dur=\"1.5s\" begin=\"0s\" repeatCount=\"indefinite\" />\r\n            </>\r\n          )}\r\n\t  </circle>\r\n\t  );\r\n    } \r\n    return null;\r\n  }\r\n}\r\n\r\n\r\n// Reset Animations on Click - needs some work - does this even do anything?\r\ndocument.addEventListener('click', function () {\r\n\t\r\n  const animatedElements = document.querySelectorAll('.hexagon');\r\n \r\n  // Add a class to pause animations\r\n  animatedElements.forEach(function (element) {\r\n    element.style.animation = 'none'; // Set animation to an empty string\r\n  });\r\n\r\n  // After 10 ms, remove the class to resume animations\r\n  setTimeout(function () {\r\n    animatedElements.forEach(function (element) {\r\n      element.style.animation = ''; // Set animation to an empty string\r\n    });\r\n  }, 10);\r\n});\r\n\r\nexport default App;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}