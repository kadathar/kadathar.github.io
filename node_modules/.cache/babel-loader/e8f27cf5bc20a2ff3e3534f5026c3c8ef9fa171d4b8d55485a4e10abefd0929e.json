{"ast":null,"code":"// GameLogic.js\n\nimport React, { Component } from 'react';\nimport { GridGenerator, HexGrid, Layout, Path, Text, Hexagon, HexUtils } from 'react-hexgrid';\nimport './App.css';\nimport ConfirmationModal from './ConfirmationModal'; // Import the ConfirmationModal component\n\n// Calculate the player's score (number of hexagons they own)\nfunction calculatePlayerScore(currentPlayer, hexagons) {\n  return hexagons.reduce((count, hex) => {\n    return hex.owner === currentPlayer.id ? count + 1 : count;\n  }, 0);\n}\n\n// Update the player's score\nfunction updatePlayerScore(players, currentPlayer, playerScore) {\n  return players.map(player => {\n    if (player.id === currentPlayer.id) {\n      return {\n        ...player,\n        score: player.score + playerScore\n      };\n    }\n    return player;\n  });\n}\n\n// Check for victory condition (score >= 100)\nfunction checkVictoryCondition(currentPlayer, playerScore) {\n  return currentPlayer.score + playerScore >= 100;\n}\n\n// Find the next valid player that is not player 0\nfunction findNextPlayerIndex(currentPlayerIndex, players) {\n  let nextPlayerIndex = (currentPlayerIndex + 1) % players.length;\n  while (players[nextPlayerIndex].id === 0) {\n    nextPlayerIndex = (nextPlayerIndex + 1) % players.length;\n  }\n  return nextPlayerIndex;\n}\n\n// Resets the \"moved\" status of all units\nfunction resetMovedUnits(hexagons) {\n  const updatedHexagons = hexagons.map(hex => {\n    return {\n      ...hex,\n      moved: false,\n      attack: false,\n      count: null\n    };\n  });\n  return updatedHexagons;\n}\n\n// Function to check if a hexagon is adjacent to to an enemy unit or surrounded by hexagons with a different owner\nfunction checkSurroundedHexagons(hexagons) {\n  const updatedHexagons = hexagons.map(hex => {\n    const adjacentHexagons = hexagons.filter(adjHex => {\n      if (HexUtils.distance(hex, adjHex) === 1) {\n        return adjHex;\n      }\n      return null;\n    });\n    const adjacentHexagons2 = hexagons.filter(adjHex2 => {\n      //this is not being used anymore?\n      if (HexUtils.distance(hex, adjHex2) === 2) {\n        return adjHex2;\n      }\n      return null;\n    });\n    const adjacentByDifferentPlayer = adjacentHexagons.length > 0 && adjacentHexagons.some(adjHex => adjHex.hasUnit && hex.hasUnit && adjHex.owner !== hex.owner);\n    if (!adjacentByDifferentPlayer) {\n      hex.adjacent = false;\n    }\n    const pushBlock = adjacentHexagons.filter(adjHex => adjHex.hasUnit && hex.hasUnit && hex.owner != adjHex.owner);\n    for (const pushHex of pushBlock) {\n      // Calculate the direction separately for each axis\n      const direction = {\n        q: pushHex.q - hex.q,\n        r: pushHex.r - hex.r,\n        s: pushHex.s - hex.s\n      };\n\n      // Calculate the position of the unit behind the adjacent hexagon\n      const behindHex = {\n        q: pushHex.q + direction.q,\n        r: pushHex.r + direction.r,\n        s: pushHex.s + direction.s\n      };\n\n      // Find the hexagon at the behindHex position\n      const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\n      if (behindHexagon == undefined) {\n        //if behindHex is outside the gameboard, we can push it\n        hex.adjacent = true;\n        return;\n      } else if (pushHex.hasUnit && !behindHexagon.hasUnit) {\n        hex.adjacent = true;\n        return;\n      } else hex.adjacent = false;\n    }\n    //PUSHBLOCK\n\n    const surroundedByDifferentPlayer = adjacentHexagons.length > 5 && adjacentHexagons.every(adjHex => adjHex.owner !== 0 && adjHex.owner !== hex.owner && adjHex.owner === adjacentHexagons[0].owner);\n    if (surroundedByDifferentPlayer) {\n      // Find the most common owner among surrounding hexagons\n      const owners = adjacentHexagons.filter(adjHex => adjHex.owner !== 0).map(adjHex => adjHex.owner);\n      const mostCommonOwner = owners.reduce((acc, owner) => ({\n        ...acc,\n        [owner]: (acc[owner] || 0) + 1\n      }), {});\n      const newOwner = parseInt(Object.keys(mostCommonOwner).find(owner => mostCommonOwner[owner] === 6) || 0);\n\n      // Update the owner to the most common owner\n      hex.owner = newOwner;\n      if (hex.hasUnit) {\n        alert('You made a new friend!');\n        // Do any necessary actions when a unit is present\n      } else {\n        // Handle when there's no unit\n        alert('You made a new friend!');\n        hex.hasUnit = true;\n      }\n    }\n    return hex;\n  });\n  return updatedHexagons;\n}\nexport { calculatePlayerScore, updatePlayerScore, checkVictoryCondition, findNextPlayerIndex, resetMovedUnits, checkSurroundedHexagons };","map":{"version":3,"names":["React","Component","GridGenerator","HexGrid","Layout","Path","Text","Hexagon","HexUtils","ConfirmationModal","calculatePlayerScore","currentPlayer","hexagons","reduce","count","hex","owner","id","updatePlayerScore","players","playerScore","map","player","score","checkVictoryCondition","findNextPlayerIndex","currentPlayerIndex","nextPlayerIndex","length","resetMovedUnits","updatedHexagons","moved","attack","checkSurroundedHexagons","adjacentHexagons","filter","adjHex","distance","adjacentHexagons2","adjHex2","adjacentByDifferentPlayer","some","hasUnit","adjacent","pushBlock","pushHex","direction","q","r","s","behindHex","behindHexagon","find","equals","undefined","surroundedByDifferentPlayer","every","owners","mostCommonOwner","acc","newOwner","parseInt","Object","keys","alert"],"sources":["C:/Users/lokorasli/Documents/GitHub/kadathar.github.io/src/GameLogic.js"],"sourcesContent":["// GameLogic.js\r\n\r\nimport React, { Component } from 'react';\r\nimport { GridGenerator, HexGrid, Layout, Path, Text, Hexagon, HexUtils } from 'react-hexgrid';\r\nimport './App.css';\r\nimport ConfirmationModal from './ConfirmationModal'; // Import the ConfirmationModal component\r\n\r\n\r\n// Calculate the player's score (number of hexagons they own)\r\nfunction calculatePlayerScore(currentPlayer, hexagons) {\r\n  return hexagons.reduce((count, hex) => {\r\n    return hex.owner === currentPlayer.id ? count + 1 : count;\r\n  }, 0);\r\n}\r\n\r\n// Update the player's score\r\nfunction updatePlayerScore(players, currentPlayer, playerScore) {\r\n  return players.map(player => {\r\n    if (player.id === currentPlayer.id) {\r\n      return { ...player, score: player.score + playerScore };\r\n    }\r\n    return player;\r\n  });\r\n}\r\n\r\n// Check for victory condition (score >= 100)\r\nfunction checkVictoryCondition(currentPlayer, playerScore) {\r\n  return currentPlayer.score + playerScore >= 100;\r\n}\r\n\r\n// Find the next valid player that is not player 0\r\nfunction findNextPlayerIndex(currentPlayerIndex, players) {\r\n  let nextPlayerIndex = (currentPlayerIndex + 1) % players.length;\r\n  while (players[nextPlayerIndex].id === 0) {\r\n    nextPlayerIndex = (nextPlayerIndex + 1) % players.length;\r\n  }\r\n  return nextPlayerIndex;\r\n}\r\n\r\n// Resets the \"moved\" status of all units\r\nfunction resetMovedUnits(hexagons) {\r\n  const updatedHexagons = hexagons.map(hex => {\r\n    return { ...hex, moved: false, attack: false, count: null};\r\n  });\r\n  return updatedHexagons;\r\n}\r\n\r\n\r\n// Function to check if a hexagon is adjacent to to an enemy unit or surrounded by hexagons with a different owner\r\nfunction checkSurroundedHexagons(hexagons) {\r\n  const updatedHexagons = hexagons.map(hex => {\r\n    const adjacentHexagons = hexagons.filter(adjHex => {\r\n      if (HexUtils.distance(hex, adjHex) === 1) {\r\n        return adjHex;\r\n      }\r\n      return null;\r\n    });\r\n\t\r\n\t\r\n   const adjacentHexagons2 = hexagons.filter(adjHex2 => { //this is not being used anymore?\r\n      if (HexUtils.distance(hex, adjHex2) === 2) {\r\n        return adjHex2;\r\n      }\r\n      return null;\r\n });\t  \r\n\t\t\r\n\tconst adjacentByDifferentPlayer = \r\n\tadjacentHexagons.length > 0 &&\r\n      adjacentHexagons.some(\r\n        adjHex => adjHex.hasUnit && hex.hasUnit && adjHex.owner !== hex.owner\r\n      );\t  \r\n\t  \r\n\tif (!adjacentByDifferentPlayer) {\r\n\t\thex.adjacent = false;\r\n\t}\t\r\n\r\n  const pushBlock = adjacentHexagons.filter(adjHex => adjHex.hasUnit && hex.hasUnit && hex.owner != adjHex.owner);\r\n \r\n  for (const pushHex of pushBlock) {\r\n    // Calculate the direction separately for each axis\r\n    const direction = {\r\n      q: pushHex.q - hex.q,\r\n      r: pushHex.r - hex.r,\r\n      s: pushHex.s - hex.s,\r\n    };\r\n\r\n    // Calculate the position of the unit behind the adjacent hexagon\r\n    const behindHex = {\r\n      q: pushHex.q + direction.q,\r\n      r: pushHex.r + direction.r,\r\n      s: pushHex.s + direction.s,\r\n    };\r\n\r\n    // Find the hexagon at the behindHex position\r\n    const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\r\n\r\n\tif (behindHexagon == undefined) {\t//if behindHex is outside the gameboard, we can push it\r\n\t\thex.adjacent = true;\r\n\t\treturn;\r\n\t } else if(pushHex.hasUnit && !behindHexagon.hasUnit) { \r\n\t\t hex.adjacent = true;\r\n\t\t return;\r\n\t }\telse\r\n\t\t hex.adjacent = false;\t \r\n  }  \r\n\t//PUSHBLOCK\r\n\r\n    const surroundedByDifferentPlayer =\r\n      adjacentHexagons.length > 5 &&\r\n      adjacentHexagons.every(\r\n        adjHex => adjHex.owner !== 0 && adjHex.owner !== hex.owner && adjHex.owner === adjacentHexagons[0].owner\r\n      );\r\n\t  \r\n    if (surroundedByDifferentPlayer) {\r\n      // Find the most common owner among surrounding hexagons\r\n      const owners = adjacentHexagons\r\n        .filter(adjHex => adjHex.owner !== 0)\r\n        .map(adjHex => adjHex.owner);\r\n\r\n      const mostCommonOwner = owners\r\n        .reduce(\r\n          (acc, owner) => ({\r\n            ...acc,\r\n            [owner]: (acc[owner] || 0) + 1\r\n          }),\r\n          {}\r\n        );\r\n\r\n      const newOwner = parseInt(\r\n        Object.keys(mostCommonOwner).find(owner => mostCommonOwner[owner] === 6) || 0\r\n      );\r\n\r\n      // Update the owner to the most common owner\r\n      hex.owner = newOwner;\r\n\r\n      if (hex.hasUnit) {\r\n        alert('You made a new friend!');\r\n        // Do any necessary actions when a unit is present\r\n      } else {\r\n        // Handle when there's no unit\r\n        alert('You made a new friend!');\r\n        hex.hasUnit = true;\r\n      }\r\n    }\r\n\t\r\n    return hex;\r\n  });\r\n\r\n  return updatedHexagons;\r\n}\r\n\r\nexport{\r\n  calculatePlayerScore,\r\n  updatePlayerScore,\r\n  checkVictoryCondition,\r\n  findNextPlayerIndex,\r\n  resetMovedUnits,\r\n  checkSurroundedHexagons\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}