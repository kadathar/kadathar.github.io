[{"C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\index.js":"1","C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\App.js":"2","C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\reportWebVitals.js":"3","C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\HexagonalGrid.js":"4","C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\ConfirmationModal.js":"5","C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\GameLogic.js":"6"},{"size":554,"mtime":1708645681564,"results":"7","hashOfConfig":"8"},{"size":361,"mtime":1708645681549,"results":"9","hashOfConfig":"8"},{"size":375,"mtime":1708645681564,"results":"10","hashOfConfig":"8"},{"size":26350,"mtime":1708645681564,"results":"11","hashOfConfig":"8"},{"size":1469,"mtime":1708645681564,"results":"12","hashOfConfig":"8"},{"size":4730,"mtime":1708645681564,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","suppressedMessages":"16","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1xprzwd",{"filePath":"17","messages":"18","suppressedMessages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26"},{"filePath":"27","messages":"28","suppressedMessages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33"},"C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\index.js",[],[],"C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\App.js",[],[],"C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\reportWebVitals.js",[],[],"C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\HexagonalGrid.js",["34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55"],[],"/* src/HexagonalGrid.js */\r\n\r\nimport React, { Component } from 'react';\r\nimport { GridGenerator, HexGrid, Layout, Path, Text, Hexagon, HexUtils } from 'react-hexgrid';\r\nimport './App.css';\r\nimport ConfirmationModal from './ConfirmationModal'; // Import the ConfirmationModal component\r\nimport { calculatePlayerScore, updatePlayerScore, checkVictoryCondition, findNextPlayerIndex, resetMovedUnits, checkSurroundedHexagons} from './GameLogic';\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // Define player representations\r\nthis.players = [\r\n  { id: 0, name: \"Player 0\", color: \"grey\", shape: \"circle\", points: 0, score: 0 },\r\n  { id: 1, name: \"Player 1\", color: \"blue\", shape: \"circle\", points: 0, score: 0 },\r\n  { id: 2, name: \"Player 2\", color: \"red\", shape: \"circle\",  points: 0,  score: 0 },\r\n];\r\n    \r\n    // Create hexagons and assign them to players\r\n    const hexagons = GridGenerator.hexagon(3).map(hex => ({\r\n      ...hex,\r\n      //owner: Math.random() < 0.5 ? 1 : 2, // Assign to player 1 or 2 - MODE 1 RANDOM\r\n\t  owner: hex.r === -3 ? 1 : hex.r === 3 ? 2 : 0, // Assign ownership based on row number - MAIN MODE\r\n      //hasUnit: Math.random() < 0.2, // Adjust the probability as needed - MODE 1 RANDOM\r\n\t  hasUnit: hex.r === -3 ? true : hex.r === 3 ? true : false, // Assign ownership based on row number - MAIN MODE\r\n      moved: false,\r\n      attack: false,\r\n\t  pushed: null,\r\n\t  adjacent: null,\r\n\t  count: 0,\r\n    }));\r\n\r\n    this.state = {\r\n      hexagons,\r\n      path: { start: null, end: null },\r\n      highlightedHexagons: [],\r\n      currentPlayer: this.players[1], // Start with the first player\r\n      selectedUnit: null,\r\n      selectedUnitPosition: null,\r\n      selectedHex: null,\r\n\t  isModalOpen: false,\r\n      isModalShownThisTurn: false,  // Track if the modal was shown this turn\r\n\t  displayMode: 'score', //default display mode\r\n    };\r\n  }\r\n\r\n\r\n\r\n  onClick(event, source) {\r\n    const { path, hexagons, selectedUnit, currentPlayer, selectedHex} = this.state;\r\n    const targetHex = source.state.hex;\r\n\t\r\n\t\r\n    // Clear previous path or selection\r\n    if (path.start == null) {\r\n      path.start = source.state.hex;\r\n    } else {\r\n      path.start = null;\r\n      path.end = null;\r\n    }\r\n\t\t\t\t\r\n\t\t\r\n    const clickedHex = hexagons.find(hex => HexUtils.equals(hex, targetHex));\r\n    const isUnitHex = clickedHex && clickedHex.hasUnit;\r\n\tthis.setState({ selectedHex: null});\r\n\r\n    // Movement Logic\r\n    if (isUnitHex && clickedHex.owner === currentPlayer.id) {\r\n      // If the clicked hexagon has a unit and the unit belongs to the current player\r\n\t  this.setState({ selectedHex: clickedHex });\r\n      if (!clickedHex.moved) {\r\n        this.setState({\r\n          selectedUnit: clickedHex,\r\n          selectedUnitPosition: targetHex,\r\n        });\r\n      } else {\r\n        this.setState({\r\n          selectedUnit: clickedHex,\r\n          selectedUnitPosition: targetHex,\r\n        });\r\n      }\r\n    } else if (selectedUnit && this.isHighlightedHex(targetHex) && !clickedHex.hasUnit ){\r\n      // If a unit is selected and a highlighted hexagon is clicked, move the unit or attack\r\n      this.moveUnit(selectedUnit, targetHex);\r\n\t  this.setState({ selectedHex: clickedHex});\r\n    } else if (this.isHighlightedHex(targetHex)) { \r\n      this.moveUnit(selectedHex, clickedHex);\r\n    }\r\n\r\n    // Highlight Controller\r\n    if (!clickedHex.moved && clickedHex.owner === currentPlayer.id) {\r\n      // Calculate highlighted hexagons that are exactly 2 hexagon distances away only if it's a unit hex\r\n      const highlightedHexagons = isUnitHex\r\n        ? hexagons.filter(hex => {\r\n          const distance = HexUtils.distance(targetHex, hex);\r\n          return distance <= 2 && !hex.hasUnit;\r\n        })\r\n        : [];\r\n      this.setState({ path, highlightedHexagons });\r\n    } else {\r\n      this.setState({ path, highlightedHexagons: [] });\r\n    }\r\n\r\n    if (clickedHex.moved && !clickedHex.attack && clickedHex.hasUnit && clickedHex.adjacent) {\r\n      // Calculate highlighted hexagons that are exactly 1 hexagon distance away only if it's a unit hex\r\n      this.highlightAttackableTiles(targetHex, currentPlayer, hexagons);\r\n    }\r\n\t\r\n// OnClick Adjacent Logic: Highlight tiles for movement and attack\r\nif (isUnitHex && !clickedHex.moved && clickedHex.owner === currentPlayer.id) {\r\n  const adjacentEnemyHexagons = hexagons.filter(hex => {\r\n    const distance = HexUtils.distance(targetHex, hex);\r\n    return distance === 1 && hex.hasUnit && hex.owner !== currentPlayer.id;\r\n  });\r\n\r\n  if (adjacentEnemyHexagons.length > 0) {\r\n    const highlightedHexagons = hexagons.filter(hex => {\r\n      const distance = HexUtils.distance(targetHex, hex);\r\n      return distance === 1 && (hex.hasUnit && hex.owner) !== currentPlayer.id;\r\n    });\r\n\t\r\n\r\n\t\r\n\t  // Check if there is a unit behind the target hexagon that can be pushed\r\n  const hasPushableUnit = highlightedHexagons.filter(hex => {\r\n    const direction = {\r\n      q: hex.q - targetHex.q,\r\n      r: hex.r - targetHex.r,\r\n      s: hex.s - targetHex.s\r\n    };\r\n\t\r\n\t\r\n\t\r\n\t    // Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\r\n    if (Math.abs(direction.q) <= 1 && Math.abs(direction.r) <= 1 && Math.abs(direction.s) <= 1) {\r\n      const behindHex = {\r\n        q: hex.q + direction.q,\r\n        r: hex.r + direction.r,\r\n        s: hex.s + direction.s\r\n      };\r\n  \r\n      // Find the hexagon at the behindHex position\r\n      const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\r\n\t  \r\n\t  const pushUnit = hexagons.find(hex => HexUtils.equals(hex, direction));\r\n\t  \r\n\t\r\n\t  \r\n\t  if(behindHexagon == undefined){\r\n\t\t \r\n\t\t  return hex;\r\n\t  }\r\n\t   else if(!behindHexagon.hasUnit){  \r\n\t   \r\n\t\treturn hex;\r\n\t  } else if(!hex.hasUnit && !behindHex.hasUnit){\r\n\t\t\r\n\t\treturn hex;\r\n\t}\r\n    }\r\n\t\r\n\t});\r\n\r\n    this.setState({ highlightedHexagons : hasPushableUnit });\t\r\n\t\r\n\t\r\n  } else {\r\n    const highlightedHexagons = hexagons.filter(hex => {\r\n      const distance = HexUtils.distance(targetHex, hex);\r\n      return distance <= 2 && !hex.hasUnit;\r\n    });\r\n\r\n    this.setState({ path, highlightedHexagons });\r\n  }\r\n}\t\r\n  } //on click ends\r\n\r\n\r\n  \r\n  // Highlights hexagons that can be attacked\r\n  highlightAttackableTiles(targetHex, currentPlayer, hexagons) {\r\n    const highlightedHexagons = hexagons.filter(hex => {\r\n      const distance = HexUtils.distance(targetHex, hex);\r\n      return distance === 1 && hex.hasUnit && hex.owner !== currentPlayer.id;\r\n    });\r\n\r\n\t\r\n\t  // Check if there is a unit behind the target hexagon that can be pushed\r\n  const hasPushableUnit = highlightedHexagons.filter(hex => {\r\n    const direction = {\r\n      q: hex.q - targetHex.q,\r\n      r: hex.r - targetHex.r,\r\n      s: hex.s - targetHex.s\r\n    };\r\n\t    // Check if the direction is valid for pushing (q, r, or s is -1, 0, or 1)\r\n    if (Math.abs(direction.q) <= 1 && Math.abs(direction.r) <= 1 && Math.abs(direction.s) <= 1) {\r\n      const behindHex = {\r\n        q: hex.q + direction.q,\r\n        r: hex.r + direction.r,\r\n        s: hex.s + direction.s\r\n      };\r\n  \r\n      // Find the hexagon at the behindHex position\r\n      const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\r\n\t  \r\n\t  const pushUnit = hexagons.find(hex => HexUtils.equals(hex, direction));\r\n\t  \r\n\t  if(behindHexagon == undefined){\r\n\t\t  return pushUnit;\r\n\t  }\r\n\t   else if(!behindHexagon.hasUnit){  \r\n\t\treturn pushUnit;\r\n\t  } \r\n    }\t\t\r\n\t});\r\n\r\n    this.setState({ highlightedHexagons : hasPushableUnit });\t\r\n\t\r\n  }\r\n  \r\n\r\n  // Checks if a hexagon is highlighted\r\n  isHighlightedHex(hex) {\r\n    const { highlightedHexagons } = this.state;\r\n    return highlightedHexagons.some(highlightedHex => HexUtils.equals(hex, highlightedHex));\r\n  }\r\n  \r\n  // Movement and Attack Mechanics\r\n  moveUnit(unitHex, targetHex) {\r\n    const { hexagons, currentPlayer, selectedUnit, selectedHex } = this.state;\r\n\t\r\n    // If the selected unit has not moved yet, move it\r\n    if (!unitHex.moved && !targetHex.hasUnit ) {\r\n      unitHex.hasUnit = false;\r\n      \r\n      // Update the target hexagon to have a unit and mark it as moved\r\n      const targetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, targetHex));\r\n      if (targetIndex !== -1) {\r\n        hexagons[targetIndex].hasUnit = true;\r\n        hexagons[targetIndex].moved = true;\r\n        hexagons[targetIndex].attack = false;\r\n        hexagons[targetIndex].owner = currentPlayer.id; // Update the owner to the current player's id\r\n      }\r\n    }  else{ //Otherwise we can only push the unit\r\n\t\t\r\n      this.pushUnit(unitHex, targetHex, hexagons, currentPlayer);\r\n\t  \r\n\r\n\t}\r\n    this.setState({\r\n      selectedUnit: null,\r\n      selectedUnitPosition: null,\r\n      hexagons: [...hexagons],\r\n      highlightedHexagons: [],\r\n    });\r\n\t\r\n\tconst updatedHexagons = checkSurroundedHexagons(this.state.hexagons);\t \r\n  }\r\n \r\n// Calculate the direction for nudge animation\r\ncalculateDirection(sourceHex, targetHex) {\r\n  const qDiff = targetHex.q - sourceHex.q;\r\n  const rDiff = targetHex.r - sourceHex.r;\r\n\r\n  if (qDiff > 0 && rDiff === 0) {\r\n    return 'East';\r\n  } else if (qDiff < 0 && rDiff === 0) {\r\n    return 'West';\r\n  } else if (qDiff === 0 && rDiff > 0) {\r\n    return 'SE';\r\n  } else if (qDiff === 0 && rDiff < 0) {\r\n    return 'NW';\r\n  } else if (qDiff > 0 && rDiff < 0) {\r\n    return 'NE';\r\n  } else if (qDiff < 0 && rDiff > 0) {\r\n    return 'SW';\r\n  }\r\n\r\n  // Handle other cases if needed\r\n\r\n  return 'unknown';\r\n}\r\n\r\n \r\n// PUSH LOGIC\r\npushUnit(sourceHex, targetHex, hexagons, currentPlayer) {\r\n  const sourceIndex = hexagons.findIndex(hex => HexUtils.equals(hex, sourceHex));\r\n  const targetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, targetHex));\r\n  \r\n\r\n  if (sourceIndex !== -1 && targetIndex !== -1) {\r\n    // Check if the target hex is empty\r\n    if (hexagons[targetIndex].hasUnit) {\r\n      // Calculate the direction of the push\r\n      const direction = {\r\n        q: targetHex.q - sourceHex.q,\r\n        r: targetHex.r - sourceHex.r,\r\n        s: targetHex.s - sourceHex.s\r\n      };\r\n\r\n      // Calculate the new position for the target unit\r\n      const newTargetHex = {\r\n        q: targetHex.q + direction.q,\r\n        r: targetHex.r + direction.r,\r\n        s: targetHex.s + direction.s\r\n      };\r\n\r\n\t\tconst newTargetIndex = hexagons.findIndex(hex => HexUtils.equals(hex, newTargetHex));\r\n\t  \r\n\t      // Check if the target hex is outside the game board\r\n\t\tconst newTargetOutsideBoard = newTargetHex.q < -3 || newTargetHex.q > 3 || newTargetHex.r < -3 || newTargetHex.r > 3 || newTargetHex.s < -3 || newTargetHex.s > 3;\r\n  \r\n\r\n\r\n      if (newTargetIndex !== -1 && !hexagons[newTargetIndex].hasUnit) {\r\n        // Move the target unit to the new position\r\n        hexagons[newTargetIndex].hasUnit = true;\r\n        hexagons[newTargetIndex].moved = false;\r\n        hexagons[newTargetIndex].attack = true; // or whatever the appropriate attack status is\r\n        hexagons[newTargetIndex].owner = hexagons[targetIndex].owner;\r\n\t\thexagons[newTargetIndex].count = hexagons[targetIndex].count + 1;\r\n\t\tcurrentPlayer.score = currentPlayer.score + hexagons[targetIndex].count + 1;\r\n\t\r\n\r\n        // Clear the target hex\r\n        hexagons[targetIndex].hasUnit = false;\r\n        hexagons[targetIndex].moved = true;\r\n        hexagons[targetIndex].attack = false;\r\n\t\thexagons[targetIndex].count = null;\r\n\r\n        // Update the owner to the current player's id\r\n        hexagons[targetIndex].owner = 0;\r\n\t\t\r\n\t\t//Update source unit so they can no longer push or move if push was successful\r\n\t\tsourceHex.attack = true;\r\n\t\tsourceHex.moved = true;\r\n\t\r\n\r\n    // Clear the highlighted hexagons and selectedHex\r\n    this.setState({\r\n      highlightedHexagons: [],\r\n      selectedHex: null  // Clear the selectedHex when a push occurs\r\n    });\r\n\t\r\n  // Calculate the direction for nudge animation target\r\nhexagons[newTargetIndex].pushed = this.calculateDirection(sourceHex, targetHex);\r\n\r\n// Calculate the direction for the nudge animation source\r\nsourceHex.pushed = 's' + this.calculateDirection(sourceHex, targetHex);\r\n \r\n\r\n// Reset the pushed class after 500 milliseconds (adjust the duration as needed)\r\nsetTimeout(() => {\r\n\t\r\n\thexagons[newTargetIndex].pushed = null;\r\n\tsourceHex.pushed = null;\r\n\tthis.setState({ hexagons: [...hexagons] }); // Update the state to re-render with the updated hexagons\r\n}, 500); // Adjust the duration (in milliseconds) as needed\r\n\t\t\t\r\n        // Clear the highlighted hexagons\r\n        this.setState({\r\n          selectedUnit: null,\r\n          selectedUnitPosition: null,\r\n          hexagons: [...hexagons],\r\n          highlightedHexagons: [],\r\n        });\r\n\t\t\r\n\t\t\r\n      } else if (newTargetOutsideBoard) {\r\n\t\t//alert('Cannot push. Target position is outside board.');\r\n\t\t\r\n\t\t//removal + animation here\r\n\r\n\t\t\r\n\t\t//Update source unit so they can no longer push or move if push was successful\r\n\t\tsourceHex.attack = true;\r\n\t\tsourceHex.moved = true;\r\n\r\n  // Calculate the direction for nudge animation target\r\nhexagons[targetIndex].pushed = 'f' + this.calculateDirection(sourceHex, targetHex);\t\t\r\n\t\t// Calculate the direction for the nudge animation source\r\nsourceHex.pushed = 's' + this.calculateDirection(sourceHex, targetHex);\r\n\t\t\r\n\t\t// Reset the pushed class after 500 milliseconds (adjust the duration as needed)\r\nsetTimeout(() => {\r\n\t\r\n\t\r\n\t\r\n\t\t        // Clear the target hex\r\n        hexagons[targetIndex].hasUnit = false;\r\n        hexagons[targetIndex].moved = true;\r\n        hexagons[targetIndex].attack = false;\r\n\t\r\n\thexagons[targetIndex].pushed = null;\r\n\tsourceHex.pushed = null;\r\n\t\r\n\tif(!hexagons[targetIndex].count){\r\n\t\thexagons[targetIndex].count = 2;\r\n\t} else hexagons[targetIndex].count = (hexagons[targetIndex].count)*2;\r\n\t\r\n\r\n\tcurrentPlayer.score = currentPlayer.score + hexagons[targetIndex].count;\r\n\r\n\t\r\n\t// Update the owner to the current player's id\r\n        hexagons[targetIndex].owner = 0;\r\n\tconst updatedHexagons = checkSurroundedHexagons(this.state.hexagons); // included here because it is not working under the move function when pushed off the edge\r\n\t\r\n\tthis.setState({ hexagons: [...hexagons] }); // Update the state to re-render with the updated hexagons\r\n}, 1000); // Adjust the duration (in milliseconds) as needed\r\n\t\t\t\r\n        // Clear the highlighted hexagons\r\n        this.setState({\r\n          selectedUnit: null,\r\n          selectedUnitPosition: null,\r\n          hexagons: [...hexagons],\r\n          highlightedHexagons: [],\r\n        });\r\n\t\t\t\r\n      } else {\r\n\t\talert('Cannot push. Target position is occupied');  \r\n\t  }\r\n    } \r\n  } \r\n}\r\n\r\n   // Function to check if the current player has any valid moves or attacks\r\nhasValidActions() {\r\n    const { hexagons, players, currentPlayer} = this.state;\r\n\t\r\n\t  const playerTileCounts = {};\r\n\r\n  // Calculate the tile count for each player\r\n  hexagons.forEach(hex => {\r\n    const owner = hex.owner;\r\n    if (owner !== null) {\r\n      if (!playerTileCounts[owner]) {\r\n        playerTileCounts[owner] = 0;\r\n      }\r\n      playerTileCounts[owner]++;\r\n    }\r\n  });\r\n\r\n currentPlayer.points = playerTileCounts[currentPlayer.id] + currentPlayer.score;\r\n\t\r\n\t\r\n\tconst hasVictory = currentPlayer.points >= 40;\r\n\r\n    // Check if the currentPlayer has any valid moves or attacks\r\n    const hasValidMoves = hexagons.some(hex => hex.owner === currentPlayer.id && hex.hasUnit && !hex.moved);\r\n\r\n    // Check if the currentPlayer has any valid attacks\r\n    const hasValidAttacks = hexagons.some(\r\n      hex =>\r\n        hex.owner === currentPlayer.id && hex.hasUnit &&\r\n        !hex.attack && hex.adjacent\r\n        \r\n    );\r\n\t\r\n\r\n\t\r\n\t\r\n      \r\n\r\n\tif(hasVictory) {\r\n\t\t\r\n\t\t\r\n\t\treturn false;\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t}else \r\n\t\t\r\n return hasValidMoves || hasValidAttacks || hasVictory;\r\n\r\n  }\r\n\r\n  handleConfirm = () => {\r\n    this.endTurn();\r\n    this.setState({ isModalOpen: false});\r\n  };\r\n\r\n  handleCancel = () => {\r\n    this.setState({ isModalOpen: false, isModalShownThisTurn: true });\r\n  };  \r\n  \r\n  \r\nhandleReset = () => {\r\n\t\r\nwindow.location.reload();\r\n\r\n  };\r\n\r\n  \r\n  \r\n  // Ends the current player's turn\r\nendTurn() {\r\n  const { currentPlayer, hexagons } = this.state;\r\n\r\n  const playerScore = calculatePlayerScore(currentPlayer, hexagons);\r\n  const updatedPlayers = updatePlayerScore(this.players, currentPlayer, playerScore);\r\n\r\n  // Update this.players (if needed) no longer using\r\n // this.players = updatedPlayers;\r\n\r\n  if (checkVictoryCondition(currentPlayer, playerScore)) { \r\n\t  \r\n\t  \r\n    alert(`${currentPlayer.name} wins with a score of ${currentPlayer.score + playerScore}!`);\r\n\t\r\n\t\r\n    // Handle game reset or victory actions here\r\n  } else {\r\n    // ... rest of the function\r\n  }\r\n\r\n  const currentPlayerIndex = this.players.findIndex(player => player.id === currentPlayer.id);\r\n  const nextPlayerIndex = findNextPlayerIndex(currentPlayerIndex, this.players);\r\n\r\n  this.setState({\r\n    selectedUnit: null,\r\n    selectedUnitPosition: null,\r\n    highlightedHexagons: [],\r\n    isModalShownThisTurn: false,\r\n    currentPlayer: this.players[nextPlayerIndex]\r\n  });\r\n  \r\n// Assuming hexagons is part of your component's state\r\nconst updatedHexagons = resetMovedUnits(this.state.hexagons);\r\n\r\n// Set the state with the updated hexagons\r\nthis.setState({ hexagons: updatedHexagons });\r\n}\r\n\r\n  \r\n\r\n  \r\nrenderPlayerStats() {\r\n  const { hexagons, currentPlayer, players, displayMode } = this.state;\r\n  const playerTileCounts = {};\r\n\r\n  // Calculate the tile count for each player\r\n  hexagons.forEach(hex => {\r\n    const owner = hex.owner;\r\n    if (owner !== null) {\r\n      if (!playerTileCounts[owner]) {\r\n        playerTileCounts[owner] = 0;\r\n      }\r\n      playerTileCounts[owner]++;\r\n    }\r\n  });\r\n\r\n \r\n\r\n  return (  // Render the tile count for each player within a HexGrid layout\r\n  \r\n    <HexGrid width={300} height={130} viewBox=\"-60 -55 120 120\">\r\n      <Layout size={{ x: 48, y: 48 }} flat={false} spacing={1.1} origin={{ x: 0, y: 0 }}>\r\n        {this.players.map(player => {\r\n          let qValue;\r\n          if (player.id === 0) {\r\n            qValue = 0; // Position player 0's hexagon in the center\r\n          } else if (player.id === 1) {\r\n            qValue = -1; // Position player 1's hexagon to the left\r\n          } else {\r\n            qValue = 1; // Position player 2's hexagon to the right\r\n          }\r\n\r\n          const isCurrentPlayer = player.id === currentPlayer.id;  // Check if this is the current player\r\n\t\t  \r\n          return (\r\n            <Hexagon\r\n              key={player.id}\r\n              q={qValue}\r\n              r={0}\r\n              s={-qValue}\r\n              owner={player.id}\r\n              className={`score ${isCurrentPlayer ? 'active' : ''}`}  // Apply 'active' class for the current player\r\n\t\t\t  opacity={isCurrentPlayer ? 1.0 : 0.0}  // Set opacity based on whether it's the current player\r\n            >\t\t\r\n            </Hexagon>\t\r\n          );\r\n        })}\r\n\t\t\r\n      </Layout>\r\n\t  \r\n\t  //this is just so the score text doesn't pulse:\r\n\t  <Layout size={{ x: 44, y: 44 }} flat={false} spacing={1.2} origin={{ x: 0, y: 0 }}>\r\n\t  {this.players.map(player => {\r\n          let qValue;\r\n          if (player.id === 0) {\r\n            qValue = 0; // Position player 0's hexagon in the center\r\n          } else if (player.id === 1) {\r\n            qValue = -1; // Position player 1's hexagon to the left\r\n          } else {\r\n            qValue = 1; // Position player 2's hexagon to the right\r\n          }\r\n\t\t            // Check if this is the current player\r\n          const isCurrentPlayer = player.id === currentPlayer.id;\r\n\t\t  \r\n          return (\r\n            <Hexagon\r\n              key={player.id}\r\n              q={qValue}\r\n              r={0}\r\n              s={-qValue}\r\n              owner={player.id}\r\n              className={\"score\"}  // Apply 'active' class for the current player\r\n\t\t\t  opacity={1}\r\n\t\t\t  onClick={() => this.toggleDisplayMode()}\r\n            >\r\n              <Text className={`score text ${player.id === 0 ? 'player-0-text' : ''}`} style={player.id === 0 ? { fontSize: '20px', fontWeight: 'bold' } : {}}>\r\n              {/*  {displayMode === 'score' ? `${playerTileCounts[player.id] || 0}` : `${player.score}`} just displays scores */}\r\n\t\t\t\t\r\n\t\t\t\t{player.id === 0 ? (displayMode === 'score' ? 'SCORE' : 'COUNT' ) : (displayMode === 'score' ?  `${player.score + playerTileCounts[player.id] }` :`${playerTileCounts[player.id] || 0}`)}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\r\n              </Text>\r\n\t\t\t  \r\n            </Hexagon>\r\n          );\r\n        })}\r\n\t  </Layout>\r\n    </HexGrid>\r\n\t\r\n\t\t\r\n\t\r\n  );\r\n}\r\n\r\n// Add this function to toggle the display mode\r\ntoggleDisplayMode() {\r\n  this.setState(prevState => ({\r\n    displayMode: prevState.displayMode === 'score' ? 'tileCount' : 'score',\r\n  }));\r\n}\r\n\r\n\r\n\r\n  render() {\r\n    const { isModalOpen, isModalShownThisTurn, hexagons, path, highlightedHexagons, selectedUnit, selectedUnitPosition, currentPlayer, selectedHex } = this.state;\r\n\t\r\n\t// Check if the current player has any valid moves or attacks\r\n    const hasValidActions = this.hasValidActions();\r\n\t\r\n\t\r\n\t // Dynamically set the button's background color based on the current player's color\r\n  const buttonStyle = {\r\n    backgroundColor: currentPlayer.color,\r\n  };\r\n\r\n\t\r\n    return (\r\n      <div className=\"App\">\r\n        <h2></h2>\r\n\t\t{this.renderPlayerStats()} {/* Render player tile counts */}  \r\n        {/* Update the button style to use the dynamic style */}\r\n      <p><button style={buttonStyle} onClick={() => this.endTurn()}>End Turn?</button></p>\r\n\t\t\r\n        <HexGrid width={900} height={800} viewBox=\"-45 -45 90 90\" >\r\n          <Layout size={{ x: 7, y: 7 }} flat={false} spacing={1.1} origin={{ x: 0, y: 0 }}>\r\n            {hexagons.map((hex, i) => (\r\n              <Hexagon\r\n                key={i}\r\n                q={hex.q}\r\n                r={hex.r}\r\n                s={hex.s}\r\n                owner={hex.owner} // Set the owner attribute based on the hexagon's owner\r\n                className={highlightedHexagons.includes(hex) ? 'active' : (selectedHex === hex ? 'selected' : '') + (hex.pushed ? hex.pushed : '')}  // Apply 'pushed' class if hexagon is pushed\r\n                onClick={(e, h) => this.onClick(e, h)}\r\n              >\r\n              {/*  <Text>{HexUtils.getID(hex)}</Text>  */}\r\n\t\t\t  {/*<Path start={path.start} end={selectedHex} /> //work on this to draw arrows*/}\r\n\t\t\t  \r\n\t\t\t  {/* ANIMATIONS HERE - still need to move CSS animations to function better */}\r\n\t\t\t  \r\n                {hex.hasUnit && (\r\n                  <ShapeRenderer\r\n                    shape={this.players[hex.owner - 1].shape} // Use the player's shape based on the owner\r\n\t\t\t\t\tfillOpacity={hex.moved && hex.attack  ? '0.5' : '1.0'}\t\t\t\t\t\t\r\n                  />\r\n                )}\r\n\t\t\t\t\r\n\t\t\t\t{!hex.attack && hex.hasUnit && (!hex.moved || hex.adjacent) && (\r\n\t\t\t\t <ShapeAnimator\r\n                    shape={this.players[hex.owner - 1].shape} // Use the player's shape based on the owner\r\n\t\t\t\t\tfillOpacity={hex.moved === true ? '0.5' : '1.0'}\t\r\n\t\t\t\t\thex={hex}\r\n\t\t\t\t\tcurrentPlayer={currentPlayer}\r\n                  />\r\n\t\t\t\t)} \r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t{hex.count && !hex.pushed && (hex.owner !== currentPlayer) && (\r\n                  <PointRenderer\r\n                    \thex={hex}\r\n\t\t\t\t\t\tcurrentPlayer={currentPlayer}\t\r\n                  />\r\n                )}\t\r\n\t\t\r\n\t\t\t {/* ANIMATIONS HERE - still need to move CSS animations to function better */}\r\n\t\t\t\r\n\t\t\t\r\n             </Hexagon>\r\n            ))}\r\n            <Path start={path.start} end={path.end} />\r\n          </Layout>\r\n        </HexGrid>\r\n        {selectedUnit && (\r\n          <p>Selected Unit: {HexUtils.getID(selectedUnitPosition)}</p>\r\n        )}\r\n        {selectedHex && (\r\n          <p>Selected Hex: {HexUtils.getID(selectedHex)}</p>\r\n        )}\r\n {/* Conditionally show the ConfirmationModal */}\r\n        { isModalShownThisTurn || hasValidActions ? true : (\r\n          <ConfirmationModal\r\n\t\t    hexagons={this.hexagons}\r\n\t\t    players={this.players}\r\n\t\t    currentPlayer = {currentPlayer}\r\n            isOpen={true} // Always open the modal when there are no valid actions\r\n\t\t\tonReset={() => this.handleReset()}\r\n            onCancel={() => this.handleCancel()}\r\n            onConfirm={() => this.handleConfirm()}\r\n          />\r\n        )}\r\n\r\n     </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nclass PointRenderer extends React.Component {\r\n\r\n  \r\n  render() {\r\n    const { hex, shape, fill, fillOpacity, className, currentPlayer } = this.props;\r\n\t\r\n    \r\n      return (      \r\n\t\t\r\n      <text\r\n        className=\"push-animation\"\r\n\t\t \r\n\t\t x=\"-0.5em\"\r\n\t\t y=\"-0.5em\" \r\n\t\t  \r\n      >\r\n        \r\n\t\t\r\n\r\n\t  +{hex.count}\r\n\t\t\r\n\t\t\r\n\t\t\r\n      </text>\r\n\t  );  \r\n    \r\n    return null;\r\n  }\r\n}\r\n\r\n\r\nclass ShapeRenderer extends React.Component {\r\n  render() {\r\n    const { shape, fill, fillOpacity, className } = this.props;\r\n    if (shape === \"circle\") {\r\n      return ( <circle cx=\"0\" cy=\"0\" r=\"1\" fill={fill} fillOpacity={fillOpacity}  className={className} >;\r\n\t  </circle>\r\n\t  );  \r\n    } \r\n    return null;\r\n  }\r\n}\r\n\r\n\r\n\r\nclass ShapeAnimator extends React.Component {\r\n  shouldAnimate() {\r\n    const { hex, currentPlayer } = this.props;\r\n    return hex.owner === currentPlayer.id;\r\n  }\t\r\n\t\r\n  render() {\r\n    const { shape, fill, fillOpacity, className } = this.props;\r\n    if (shape === \"circle\") {\r\n      return ( <circle cx=\"0\" cy=\"0\" r=\"1\" fill={fill} fillOpacity={fillOpacity}  className={className}>;\r\n          {this.shouldAnimate() && (\r\n            <>\r\n              <animate attributeName=\"r\" from=\"1\" to=\"2\" dur=\"1.5s\" begin=\"0s\" repeatCount=\"indefinite\" />\r\n              <animate attributeName=\"opacity\" from=\"1\" to=\"0\" dur=\"1.5s\" begin=\"0s\" repeatCount=\"indefinite\" />\r\n            </>\r\n          )}\r\n\t  </circle>\r\n\t  );\r\n    } \r\n    return null;\r\n  }\r\n}\r\n\r\n\r\n// Reset Animations on Click - needs some work - does this even do anything?\r\ndocument.addEventListener('click', function () {\r\n\t\r\n  const animatedElements = document.querySelectorAll('.hexagon');\r\n \r\n  // Add a class to pause animations\r\n  animatedElements.forEach(function (element) {\r\n    element.style.animation = 'none'; // Set animation to an empty string\r\n  });\r\n\r\n  // After 10 ms, remove the class to resume animations\r\n  setTimeout(function () {\r\n    animatedElements.forEach(function (element) {\r\n      element.style.animation = ''; // Set animation to an empty string\r\n    });\r\n  }, 10);\r\n});\r\n\r\nexport default App;\r\n","C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\ConfirmationModal.js",[],[],"C:\\Users\\lokorasli\\Documents\\GitHub\\kadathar.github.io\\src\\GameLogic.js",["56","57","58","59","60","61","62","63","64","65","66","67","68","69"],[],"// GameLogic.js\r\n\r\nimport React, { Component } from 'react';\r\nimport { GridGenerator, HexGrid, Layout, Path, Text, Hexagon, HexUtils } from 'react-hexgrid';\r\nimport './App.css';\r\nimport ConfirmationModal from './ConfirmationModal'; // Import the ConfirmationModal component\r\n\r\n\r\n// Calculate the player's score (number of hexagons they own)\r\nfunction calculatePlayerScore(currentPlayer, hexagons) {\r\n  return hexagons.reduce((count, hex) => {\r\n    return hex.owner === currentPlayer.id ? count + 1 : count;\r\n  }, 0);\r\n}\r\n\r\n// Update the player's score\r\nfunction updatePlayerScore(players, currentPlayer, playerScore) {\r\n  return players.map(player => {\r\n    if (player.id === currentPlayer.id) {\r\n      return { ...player, score: player.score + playerScore };\r\n    }\r\n    return player;\r\n  });\r\n}\r\n\r\n// Check for victory condition (score >= 100)\r\nfunction checkVictoryCondition(currentPlayer, playerScore) {\r\n  return currentPlayer.score + playerScore >= 100;\r\n}\r\n\r\n// Find the next valid player that is not player 0\r\nfunction findNextPlayerIndex(currentPlayerIndex, players) {\r\n  let nextPlayerIndex = (currentPlayerIndex + 1) % players.length;\r\n  while (players[nextPlayerIndex].id === 0) {\r\n    nextPlayerIndex = (nextPlayerIndex + 1) % players.length;\r\n  }\r\n  return nextPlayerIndex;\r\n}\r\n\r\n// Resets the \"moved\" status of all units\r\nfunction resetMovedUnits(hexagons) {\r\n  const updatedHexagons = hexagons.map(hex => {\r\n    return { ...hex, moved: false, attack: false, count: null};\r\n  });\r\n  return updatedHexagons;\r\n}\r\n\r\n\r\n// Function to check if a hexagon is adjacent to to an enemy unit or surrounded by hexagons with a different owner\r\nfunction checkSurroundedHexagons(hexagons) {\r\n  const updatedHexagons = hexagons.map(hex => {\r\n    const adjacentHexagons = hexagons.filter(adjHex => {\r\n      if (HexUtils.distance(hex, adjHex) === 1) {\r\n        return adjHex;\r\n      }\r\n      return null;\r\n    });\r\n\t\r\n\t\r\n   const adjacentHexagons2 = hexagons.filter(adjHex2 => { //this is not being used anymore?\r\n      if (HexUtils.distance(hex, adjHex2) === 2) {\r\n        return adjHex2;\r\n      }\r\n      return null;\r\n });\t  \r\n\t\t\r\n\tconst adjacentByDifferentPlayer = \r\n\tadjacentHexagons.length > 0 &&\r\n      adjacentHexagons.some(\r\n        adjHex => adjHex.hasUnit && hex.hasUnit && adjHex.owner !== hex.owner\r\n      );\t  \r\n\t  \r\n\tif (!adjacentByDifferentPlayer) {\r\n\t\thex.adjacent = false;\r\n\t}\t\r\n\r\n  const pushBlock = adjacentHexagons.filter(adjHex => adjHex.hasUnit && hex.hasUnit && hex.owner != adjHex.owner);\r\n \r\n  for (const pushHex of pushBlock) {\r\n    // Calculate the direction separately for each axis\r\n    const direction = {\r\n      q: pushHex.q - hex.q,\r\n      r: pushHex.r - hex.r,\r\n      s: pushHex.s - hex.s,\r\n    };\r\n\r\n    // Calculate the position of the unit behind the adjacent hexagon\r\n    const behindHex = {\r\n      q: pushHex.q + direction.q,\r\n      r: pushHex.r + direction.r,\r\n      s: pushHex.s + direction.s,\r\n    };\r\n\r\n    // Find the hexagon at the behindHex position\r\n    const behindHexagon = hexagons.find(hex => HexUtils.equals(hex, behindHex));\r\n\r\n\tif (behindHexagon == undefined) {\t//if behindHex is outside the gameboard, we can push it\r\n\t\thex.adjacent = true;\r\n\t\treturn;\r\n\t } else if(pushHex.hasUnit && !behindHexagon.hasUnit) { \r\n\t\t hex.adjacent = true;\r\n\t\t return;\r\n\t }\telse\r\n\t\t hex.adjacent = false;\t \r\n  }  \r\n\t//PUSHBLOCK\r\n\r\n    const surroundedByDifferentPlayer =\r\n      adjacentHexagons.length > 5 &&\r\n      adjacentHexagons.every(\r\n        adjHex => adjHex.owner !== 0 && adjHex.owner !== hex.owner && adjHex.owner === adjacentHexagons[0].owner\r\n      );\r\n\t  \r\n    if (surroundedByDifferentPlayer) {\r\n      // Find the most common owner among surrounding hexagons\r\n      const owners = adjacentHexagons\r\n        .filter(adjHex => adjHex.owner !== 0)\r\n        .map(adjHex => adjHex.owner);\r\n\r\n      const mostCommonOwner = owners\r\n        .reduce(\r\n          (acc, owner) => ({\r\n            ...acc,\r\n            [owner]: (acc[owner] || 0) + 1\r\n          }),\r\n          {}\r\n        );\r\n\r\n      const newOwner = parseInt(\r\n        Object.keys(mostCommonOwner).find(owner => mostCommonOwner[owner] === 6) || 0\r\n      );\r\n\r\n      // Update the owner to the most common owner\r\n      hex.owner = newOwner;\r\n\r\n      if (hex.hasUnit) {\r\n        alert('You made a new friend!');\r\n        // Do any necessary actions when a unit is present\r\n      } else {\r\n        // Handle when there's no unit\r\n        alert('You made a new friend!');\r\n        hex.hasUnit = true;\r\n      }\r\n    }\r\n\t\r\n    return hex;\r\n  });\r\n\r\n  return updatedHexagons;\r\n}\r\n\r\nexport{\r\n  calculatePlayerScore,\r\n  updatePlayerScore,\r\n  checkVictoryCondition,\r\n  findNextPlayerIndex,\r\n  resetMovedUnits,\r\n  checkSurroundedHexagons\r\n};\r\n",{"ruleId":"70","severity":1,"message":"71","line":126,"column":58,"nodeType":"72","messageId":"73","endLine":126,"endColumn":60},{"ruleId":"74","severity":1,"message":"75","line":146,"column":10,"nodeType":"76","messageId":"77","endLine":146,"endColumn":18},{"ruleId":"78","severity":1,"message":"79","line":150,"column":21,"nodeType":"80","messageId":"81","endLine":150,"endColumn":23},{"ruleId":"70","severity":1,"message":"71","line":190,"column":58,"nodeType":"72","messageId":"73","endLine":190,"endColumn":60},{"ruleId":"78","severity":1,"message":"79","line":209,"column":21,"nodeType":"80","messageId":"81","endLine":209,"endColumn":23},{"ruleId":"74","severity":1,"message":"82","line":231,"column":38,"nodeType":"76","messageId":"77","endLine":231,"endColumn":50},{"ruleId":"74","severity":1,"message":"83","line":231,"column":52,"nodeType":"76","messageId":"77","endLine":231,"endColumn":63},{"ruleId":"74","severity":1,"message":"84","line":258,"column":8,"nodeType":"76","messageId":"77","endLine":258,"endColumn":23},{"ruleId":"74","severity":1,"message":"84","line":408,"column":8,"nodeType":"76","messageId":"77","endLine":408,"endColumn":23},{"ruleId":"74","severity":1,"message":"85","line":430,"column":23,"nodeType":"76","messageId":"77","endLine":430,"endColumn":30},{"ruleId":"74","severity":1,"message":"86","line":502,"column":9,"nodeType":"76","messageId":"77","endLine":502,"endColumn":23},{"ruleId":"74","severity":1,"message":"85","line":540,"column":36,"nodeType":"76","messageId":"77","endLine":540,"endColumn":43},{"ruleId":"87","severity":1,"message":"88","line":586,"column":16,"nodeType":"89","messageId":"90","endLine":589,"endColumn":4},{"ruleId":"74","severity":1,"message":"91","line":600,"column":17,"nodeType":"76","messageId":"77","endLine":600,"endColumn":32},{"ruleId":"74","severity":1,"message":"92","line":642,"column":13,"nodeType":"76","messageId":"77","endLine":642,"endColumn":24},{"ruleId":"93","severity":1,"message":"94","line":656,"column":9,"nodeType":"95","endLine":656,"endColumn":13},{"ruleId":"74","severity":1,"message":"96","line":739,"column":18,"nodeType":"76","messageId":"77","endLine":739,"endColumn":23},{"ruleId":"74","severity":1,"message":"97","line":739,"column":25,"nodeType":"76","messageId":"77","endLine":739,"endColumn":29},{"ruleId":"74","severity":1,"message":"98","line":739,"column":31,"nodeType":"76","messageId":"77","endLine":739,"endColumn":42},{"ruleId":"74","severity":1,"message":"99","line":739,"column":44,"nodeType":"76","messageId":"77","endLine":739,"endColumn":53},{"ruleId":"74","severity":1,"message":"100","line":739,"column":55,"nodeType":"76","messageId":"77","endLine":739,"endColumn":68},{"ruleId":"101","severity":1,"message":"102","line":761,"column":5,"nodeType":"103","messageId":"104","endLine":761,"endColumn":17},{"ruleId":"74","severity":1,"message":"105","line":3,"column":8,"nodeType":"76","messageId":"77","endLine":3,"endColumn":13},{"ruleId":"74","severity":1,"message":"106","line":3,"column":17,"nodeType":"76","messageId":"77","endLine":3,"endColumn":26},{"ruleId":"74","severity":1,"message":"107","line":4,"column":10,"nodeType":"76","messageId":"77","endLine":4,"endColumn":23},{"ruleId":"74","severity":1,"message":"108","line":4,"column":25,"nodeType":"76","messageId":"77","endLine":4,"endColumn":32},{"ruleId":"74","severity":1,"message":"109","line":4,"column":34,"nodeType":"76","messageId":"77","endLine":4,"endColumn":40},{"ruleId":"74","severity":1,"message":"110","line":4,"column":42,"nodeType":"76","messageId":"77","endLine":4,"endColumn":46},{"ruleId":"74","severity":1,"message":"111","line":4,"column":48,"nodeType":"76","messageId":"77","endLine":4,"endColumn":52},{"ruleId":"74","severity":1,"message":"112","line":4,"column":54,"nodeType":"76","messageId":"77","endLine":4,"endColumn":61},{"ruleId":"74","severity":1,"message":"113","line":6,"column":8,"nodeType":"76","messageId":"77","endLine":6,"endColumn":25},{"ruleId":"74","severity":1,"message":"114","line":60,"column":10,"nodeType":"76","messageId":"77","endLine":60,"endColumn":27},{"ruleId":"78","severity":1,"message":"115","line":77,"column":98,"nodeType":"80","messageId":"81","endLine":77,"endColumn":100},{"ruleId":"78","severity":1,"message":"79","line":97,"column":20,"nodeType":"80","messageId":"81","endLine":97,"endColumn":22},{"ruleId":"70","severity":1,"message":"116","line":99,"column":3,"nodeType":"103","messageId":"117","endLine":99,"endColumn":10},{"ruleId":"70","severity":1,"message":"116","line":102,"column":4,"nodeType":"103","messageId":"117","endLine":102,"endColumn":11},"array-callback-return","Array.prototype.filter() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","no-unused-vars","'pushUnit' is assigned a value but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'selectedUnit' is assigned a value but never used.","'selectedHex' is assigned a value but never used.","'updatedHexagons' is assigned a value but never used.","'players' is assigned a value but never used.","'updatedPlayers' is assigned a value but never used.","react/jsx-no-comment-textnodes","Comments inside children section of tag should be placed inside braces","JSXText","putCommentInBraces","'isCurrentPlayer' is assigned a value but never used.","'isModalOpen' is assigned a value but never used.","jsx-a11y/heading-has-content","Headings must have content and the content must be accessible by a screen reader.","JSXOpeningElement","'shape' is assigned a value but never used.","'fill' is assigned a value but never used.","'fillOpacity' is assigned a value but never used.","'className' is assigned a value but never used.","'currentPlayer' is assigned a value but never used.","no-unreachable","Unreachable code.","ReturnStatement","unreachableCode","'React' is defined but never used.","'Component' is defined but never used.","'GridGenerator' is defined but never used.","'HexGrid' is defined but never used.","'Layout' is defined but never used.","'Path' is defined but never used.","'Text' is defined but never used.","'Hexagon' is defined but never used.","'ConfirmationModal' is defined but never used.","'adjacentHexagons2' is assigned a value but never used.","Expected '!==' and instead saw '!='.","Array.prototype.map() expects a return value from arrow function.","expectedReturnValue"]